<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HibernateCacheLoader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Coherence Hibernate Website</a> &gt; <a href="../index.html" class="el_bundle">coherence-hibernate-cache-store</a> &gt; <a href="index.source.html" class="el_package">com.oracle.coherence.hibernate.cachestore</a> &gt; <span class="el_source">HibernateCacheLoader.java</span></div><h1>HibernateCacheLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2023, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */
package com.oracle.coherence.hibernate.cachestore;

import java.io.File;
import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.tangosol.net.cache.CacheLoader;
import com.tangosol.util.Base;
import org.hibernate.CacheMode;
import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.engine.spi.SessionImplementor;
import org.hibernate.metadata.ClassMetadata;
import org.hibernate.metamodel.spi.MetamodelImplementor;
import org.hibernate.query.Query;

/**
 * Data-driven CacheLoader implementation for Hibernate tables.
 * &lt;p&gt;
 * These methods all follow the pattern of:
 * &lt;ol&gt;
 *   &lt;li&gt;open session&lt;/li&gt;
 *   &lt;li&gt;begin transaction&lt;/li&gt;
 *   &lt;li&gt;do work&lt;/li&gt;
 *   &lt;li&gt;commit transaction (or rollback on exception and rethrow)&lt;/li&gt;
 *   &lt;li&gt;close session&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @author jp 2005.09.15
 * @author pp 2009.01.23
 * @author rs 2013.09.05
 * @author Gunnar Hillert
 */
public class HibernateCacheLoader extends Base implements CacheLoader {

    /**
     * Name of the &quot;ids&quot; named parameter in HQL bulk queries.
     */
    protected static final String PARAM_IDS = &quot;ids&quot;;

    /**
     * Has this instance been initialized?
     */
    private boolean initialized;

    /**
     * ClassMetadata object for this CacheLoader's entity type (has pseudo-final semantics, and is guarded by
     * ensureInitialized()).
     */
    private ClassMetadata entityClassMetadata;

    /**
     * An HQL query string for loadAll (has pseudo-final semantics, and is guarded by ensureInitialized()).
     */
    private volatile String loadAllQuery;

    /**
     * The entity name.
     */
    private volatile String entityName;

    /**
     * The Hibernate SessionFactory (the instance's copy).
     */
    private SessionFactory sessionFactory;

    /**
     * Default constructor. If using this constructor, it is expected that
     * the {@code entityName} and {@code sessionFactory} attributes will
     * be set prior to usage.
     */
<span class="nc" id="L83">    public HibernateCacheLoader() {</span>
<span class="nc" id="L84">    }</span>

    /**
     * Constructor which accepts an entityName. Configures Hibernate using
     * the default Hibernate configuration. The current implementation parses
     * this file once-per-instance (there is typically a single instance per).
     * @param entityName the Hibernate entity (i.e., the HQL table name)
     */
<span class="nc" id="L92">    public HibernateCacheLoader(String entityName) {</span>
<span class="nc" id="L93">        this.entityName = entityName;</span>

        // Configure using the default Hibernate configuration.
<span class="nc" id="L96">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L97">        configuration.configure();</span>

<span class="nc" id="L99">        this.sessionFactory = configuration.buildSessionFactory();</span>
<span class="nc" id="L100">    }</span>

    /**
     * Constructor which accepts an entityName and a Hibernate configuration
     * resource. The current implementation instantiates a SessionFactory per
     * instance (implying one instance per CacheStore-backed NamedCache).
     * @param entityName the Hibernate entity (i.e. the HQL table name)
     * @param resource the Hibernate config classpath resource (e.g. hibernate.cfg.xml)
     */
<span class="nc" id="L109">    public HibernateCacheLoader(String entityName, String resource) {</span>
<span class="nc" id="L110">        this.entityName = entityName;</span>

        /*
        If we start caching these we need to be aware that the resource may
        be relative (and so we should not key the cache by resource name).
        */
<span class="nc" id="L116">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L117">        configuration.configure(resource);</span>

<span class="nc" id="L119">        this.sessionFactory = configuration.buildSessionFactory();</span>
<span class="nc" id="L120">    }</span>

    /**
     * Constructor which accepts an entityName and a Hibernate configuration
     * resource. The current implementation instantiates a SessionFactory per
     * instance (implying one instance per CacheStore-backed NamedCache).
     * @param entityName the Hibernate entity (i.e. the HQL table name)
     * @param configurationFile the Hibernate config file (e.g. hibernate.cfg.xml)
     */
<span class="nc" id="L129">    public HibernateCacheLoader(String entityName, File configurationFile) {</span>
<span class="nc" id="L130">        this.entityName = entityName;</span>

        /*
        If we start caching these we should cache by canonical file name.
        */
<span class="nc" id="L135">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L136">        configuration.configure(configurationFile);</span>

<span class="nc" id="L138">        this.sessionFactory = configuration.buildSessionFactory();</span>
<span class="nc" id="L139">    }</span>

    /**
     * Constructor which accepts an entityName and a Hibernate {@code SessionFactory}.
     * This allows for external configuration of the SessionFactory (for instance using Spring).
     * @param entityName the Hibernate entity (i.e. the HQL table name)
     * @param sessionFactory the Hibernate SessionFactory
     */
<span class="nc" id="L147">    public HibernateCacheLoader(String entityName, SessionFactory sessionFactory) {</span>
<span class="nc" id="L148">        this.entityName = entityName;</span>
<span class="nc" id="L149">        this.sessionFactory = sessionFactory;</span>
<span class="nc" id="L150">    }</span>


    // ----- accessors -----------------------------------------------------

    /**
     * Get the Hibernate SessionFactory.
     * @return the Hibernate SessionFactory
     */
    public SessionFactory getSessionFactory() {
<span class="nc" id="L160">        return this.sessionFactory;</span>
    }

    /**
     * Set the Hibernate SessionFactory to be used by this CacheLoader.  This
     * attribute can only be set once during the lifecycle of an instance.
     * @param sessionFactory the Hibernate SessionFactory
     * @throws IllegalStateException  if the session factory has already been set
     */
    public synchronized void setSessionFactory(SessionFactory sessionFactory) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (this.sessionFactory != null) {</span>
<span class="nc" id="L171">            throw new IllegalStateException(&quot;SessionFactory has already been set&quot;);</span>
        }
<span class="nc" id="L173">        this.sessionFactory = sessionFactory;</span>
<span class="nc" id="L174">    }</span>

    /**
     * Get the Hibernate entity name.
     * @return the entity name
     */
    protected String getEntityName() {
<span class="nc" id="L181">        return this.entityName;</span>
    }

    /**
     * Set the Hibernate entity name. This attribute can only be set once
     * during the lifecycle of an instance.
     * @param entityName the entity name
     * @throws IllegalStateException if the entity name has already been set
     */
    public synchronized void setEntityName(String entityName) {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (this.entityName != null) {</span>
<span class="nc" id="L192">            throw new IllegalStateException(&quot;Entity name has already been set&quot;);</span>
        }
<span class="nc" id="L194">        this.entityName = entityName;</span>
<span class="nc" id="L195">    }</span>

    // ----- Initialization methods ----------------------------------------

    /**
     * Initializer (must be called post-constructor).
     * &lt;p&gt;
     * We do this specifically so that derived classes can safely create
     * override methods that depend on a fully constructed object state.
     * Will only be called once per instance and prior to the main body
     * of any API methods. This should not be directly called by derived
     * classes. If this method is overridden, super must be called at the
     * end of the overriding method.
     */
    protected void initialize() {

<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (this.entityName == null) {</span>
<span class="nc" id="L212">            throw new IllegalStateException(&quot;Entity name attribute was not set&quot;);</span>
        }

<span class="nc" id="L215">        final SessionFactory sessionFactory = getSessionFactory();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (sessionFactory == null) {</span>
            // Can only occur with derived classes
<span class="nc" id="L218">            throw new IllegalStateException(&quot;No session factory was specified, &quot; +</span>
                    &quot;and a hibernate configuration file was not provided.&quot;);
        }

        // Look up the Hibernate metadata for the entity
<span class="nc" id="L223">        final MetamodelImplementor metamodel = (MetamodelImplementor) sessionFactory.getMetamodel();</span>
<span class="nc" id="L224">        final ClassMetadata entityClassMetadata = (ClassMetadata) metamodel.entityPersister(this.entityName);</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (entityClassMetadata == null) {</span>
<span class="nc" id="L227">            throw new RuntimeException(&quot;Unable to find ClassMetadata&quot; +</span>
                    &quot; for Hibernate entity &quot; + this.entityName + &quot;.&quot;);
        }
<span class="nc" id="L230">        setEntityClassMetadata(entityClassMetadata);</span>
<span class="nc" id="L231">    }</span>

    /**
     * Called by all API-implementing methods for lazy initialization. This
     * should never be called from a constructor.
     */
    protected synchronized void ensureInitialized() {
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (!this.initialized) {</span>
<span class="nc" id="L239">            initialize();</span>
<span class="nc" id="L240">            this.initialized = true;</span>
        }
<span class="nc" id="L242">    }</span>


    // ----- CacheLoader API methods ----------------------------------------

    /**
     * Load a Hibernate entity given an id (key).
     * @param key the cache key; specifically, the entity id
     * @return the corresponding Hibernate entity instance
     */
    public Object load(Object key) {
<span class="nc" id="L253">        ensureInitialized();</span>

<span class="nc" id="L255">        Transaction transaction = null;</span>

<span class="nc" id="L257">        Object value = null;</span>

<span class="nc" id="L259">        final Session session = openSession();</span>

        try {
<span class="nc" id="L262">            transaction = session.beginTransaction();</span>

            // The Hibernate docs indicate that the returned value is
            // sufficiently &quot;detached&quot; for our purposes (without explicitly
            // converting the state to transient).
<span class="nc" id="L267">            value = session.get(getEntityName(), (Serializable) key);</span>

<span class="nc" id="L269">            transaction.commit();</span>
        }
<span class="nc" id="L271">        catch (Exception ex) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (transaction != null) {</span>
<span class="nc" id="L273">                transaction.rollback();</span>
            }

<span class="nc" id="L276">            throw ensureRuntimeException(ex);</span>
        }
        finally {
<span class="nc" id="L279">            closeSession(session);</span>
        }

<span class="nc" id="L282">        return value;</span>
    }

    /**
     * Load a collection of Hibernate entities given a set of ids (keys).
     * @param keys the cache keys; specifically, the entity ids. By default, entities will be returned in the order of the
     *              provided List of keys
     * @return the corresponding Hibernate entity instances
     */
    public Map loadAll(List keys) {
<span class="nc" id="L292">        ensureInitialized();</span>

<span class="nc" id="L294">        final Map results = new HashMap();</span>

<span class="nc" id="L296">        Transaction transaction = null;</span>

<span class="nc" id="L298">        final Session session = openSession();</span>
<span class="nc" id="L299">        final SessionImplementor sessionImplementor = (SessionImplementor) session;</span>

        try {
<span class="nc" id="L302">            transaction = session.beginTransaction();</span>

            final List&lt;?&gt; result;
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (this.getLoadAllQuery() != null) {</span>
                // Create the query
<span class="nc" id="L307">                final String sQuery = getLoadAllQuery();</span>
<span class="nc" id="L308">                final Query query = session.createQuery(sQuery);</span>

                // Prevent Hibernate from caching the results
<span class="nc" id="L311">                query.setCacheMode(CacheMode.IGNORE);</span>
<span class="nc" id="L312">                query.setCacheable(false);</span>
<span class="nc" id="L313">                query.setReadOnly(true);</span>

                // Parameterize the query (where :keys = keys)
<span class="nc" id="L316">                query.setParameterList(PARAM_IDS, keys);</span>
<span class="nc" id="L317">                result = query.list();</span>
<span class="nc" id="L318">            }</span>
            else {
<span class="nc" id="L320">                result = session.byMultipleIds(this.entityName)</span>
<span class="nc" id="L321">                        .with(CacheMode.IGNORE)</span>
<span class="nc" id="L322">                        .multiLoad(keys);</span>
            }

            // Need a way to extract the key from an entity that we know
            // nothing about.
<span class="nc" id="L327">            final ClassMetadata classMetaData = getEntityClassMetadata();</span>

<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (Object entity : result) {</span>
<span class="nc" id="L330">                final Object[] propertyValues = classMetaData.getPropertyValues(entity);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                for (Object propertyValue : propertyValues) {</span>
<span class="nc" id="L332">                    Hibernate.initialize(propertyValue);</span>
                }
<span class="nc" id="L334">            }</span>

            // Iterate through the results and place into the return map
<span class="nc bnc" id="L337" title="All 2 branches missed.">            for (Object entity : result) {</span>
<span class="nc" id="L338">                final Object id = classMetaData.getIdentifier(entity, sessionImplementor);</span>
<span class="nc" id="L339">                results.put(id, entity);</span>
<span class="nc" id="L340">            }</span>
<span class="nc" id="L341">            transaction.commit();</span>
        }
<span class="nc" id="L343">        catch (Exception ex) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (transaction != null) {</span>
<span class="nc" id="L345">                transaction.rollback();</span>
            }
<span class="nc" id="L347">            throw ensureRuntimeException(ex);</span>
        }
        finally {
<span class="nc" id="L350">            closeSession(session);</span>
        }

<span class="nc" id="L353">        return results;</span>
    }

    // ----- Helper methods -------------------------------------------------

    /**
     * Open a Hibernate Session.
     * @return the Hibernate Session object
     */
    protected Session openSession() {
<span class="nc" id="L363">        return getSessionFactory().openSession();</span>
    }

    /**
     * Close a Hibernate Session.
     * @param session the Hibernate Session object
     */
    protected void closeSession(Session session) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        azzert(session != null, &quot;Attempted to close a null session.&quot;);</span>
<span class="nc" id="L372">        session.close();</span>
<span class="nc" id="L373">    }</span>

    /**
     * Get the Hibernate ClassMetadata for the Hibernate entity.
     * @return the ClassMetadata object
     */
    protected ClassMetadata getEntityClassMetadata() {
<span class="nc" id="L380">        return this.entityClassMetadata;</span>
    }

    /**
     * Get the Hibernate ClassMetadata for the Hibernate entity.
     * @param entityClassMetadata the ClassMetadata object
     */
    protected void setEntityClassMetadata(ClassMetadata entityClassMetadata) {
<span class="nc" id="L388">        this.entityClassMetadata = entityClassMetadata;</span>
<span class="nc" id="L389">    }</span>

    /**
     * Get the parameterized loadAll HQL query string.
     * @return  a parameterized HQL query string
     */
    protected String getLoadAllQuery() {
<span class="nc" id="L396">        return this.loadAllQuery;</span>
    }

    /**
     * Get the parameterized loadAll HQL query string.
     * @param sLoadAllQuery a parameterized HQL query string
     */
    protected void setLoadAllQuery(String sLoadAllQuery) {
<span class="nc" id="L404">        this.loadAllQuery = sLoadAllQuery;</span>
<span class="nc" id="L405">    }</span>

    /**
     * Create a transient entity instance given an entity id.
     * @param id the Hibernate entity id
     * @param sessionImplementor the Hibernate SessionImplementor
     * @return the Hibernate entity (may return null)
     */
    protected Object createEntityFromId(Object id, SessionImplementor sessionImplementor) {
<span class="nc" id="L414">        final ClassMetadata cmd = getEntityClassMetadata();</span>
<span class="nc" id="L415">        final Object o = cmd.instantiate(id, sessionImplementor);</span>
<span class="nc" id="L416">        return o;</span>
    }

    /**
     * Ensure that there are no conflicts between an explicit and implicit key.
     * @param id the explicit key
     * @param entity an entity (containing an implicit key)
     * @param sessionImplementor the Hibernate SessionImplementor
     */
    protected void validateIdentifier(Serializable id, Object entity, SessionImplementor sessionImplementor) {
<span class="nc" id="L426">        final ClassMetadata classMetaData = getEntityClassMetadata();</span>

<span class="nc" id="L428">        final Object intrinsicIdentifier =</span>
<span class="nc" id="L429">                classMetaData.getIdentifier(entity, sessionImplementor);</span>

<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (intrinsicIdentifier == null) {</span>
<span class="nc" id="L432">            classMetaData</span>
<span class="nc" id="L433">                    .setIdentifier(entity, id, sessionImplementor);</span>
        }
        else {
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (!intrinsicIdentifier.equals(id)) {</span>
<span class="nc" id="L437">                throw new IllegalArgumentException(&quot;Conflicting identifier &quot; +</span>
                        &quot;information between entity &quot; + entity + &quot; and id &quot; + id);
            }
        }
<span class="nc" id="L441">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>