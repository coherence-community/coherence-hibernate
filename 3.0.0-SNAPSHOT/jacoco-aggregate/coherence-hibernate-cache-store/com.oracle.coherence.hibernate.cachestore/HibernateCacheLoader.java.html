<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HibernateCacheLoader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Coherence Hibernate Website</a> &gt; <a href="../index.html" class="el_bundle">coherence-hibernate-cache-store</a> &gt; <a href="index.source.html" class="el_package">com.oracle.coherence.hibernate.cachestore</a> &gt; <span class="el_source">HibernateCacheLoader.java</span></div><h1>HibernateCacheLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2023, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */
package com.oracle.coherence.hibernate.cachestore;

import java.io.File;
import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.tangosol.net.cache.CacheLoader;
import com.tangosol.util.Base;
import org.hibernate.CacheMode;
import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.UnknownEntityTypeException;
import org.hibernate.cfg.Configuration;
import org.hibernate.engine.spi.SessionImplementor;
import org.hibernate.engine.spi.SharedSessionContractImplementor;
import org.hibernate.metamodel.MappingMetamodel;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.query.Query;

/**
 * Data-driven CacheLoader implementation for Hibernate tables.
 * &lt;p&gt;
 * These methods all follow the pattern of:
 * &lt;ol&gt;
 *   &lt;li&gt;open session&lt;/li&gt;
 *   &lt;li&gt;begin transaction&lt;/li&gt;
 *   &lt;li&gt;do work&lt;/li&gt;
 *   &lt;li&gt;commit transaction (or rollback on exception and rethrow)&lt;/li&gt;
 *   &lt;li&gt;close session&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @author jp 2005.09.15
 * @author pp 2009.01.23
 * @author rs 2013.09.05
 * @author Gunnar Hillert
 */
public class HibernateCacheLoader extends Base implements CacheLoader {

    /**
     * Name of the &quot;ids&quot; named parameter in HQL bulk queries.
     */
    protected static final String PARAM_IDS = &quot;ids&quot;;

    /**
     * Has this instance been initialized?
     */
    private boolean initialized;

    /**
     * ClassMetadata object for this CacheLoader's entity type (has pseudo-final semantics, and is guarded by
     * ensureInitialized()).
     */
    private EntityPersister entityClassMetadata;

    /**
     * An HQL query string for loadAll (has pseudo-final semantics, and is guarded by ensureInitialized()).
     */
    private volatile String loadAllQuery;

    /**
     * The entity name.
     */
    private volatile String entityName;

    /**
     * The Hibernate SessionFactory (the instance's copy).
     */
    private SessionFactory sessionFactory;

    /**
     * Default constructor. If using this constructor, it is expected that
     * the {@code entityName} and {@code sessionFactory} attributes will
     * be set prior to usage.
     */
<span class="nc" id="L85">    public HibernateCacheLoader() {</span>
<span class="nc" id="L86">    }</span>

    /**
     * Constructor which accepts an entityName. Configures Hibernate using
     * the default Hibernate configuration. The current implementation parses
     * this file once-per-instance (there is typically a single instance per).
     * @param entityName the Hibernate entity (i.e., the HQL table name)
     */
<span class="nc" id="L94">    public HibernateCacheLoader(String entityName) {</span>
<span class="nc" id="L95">        this.entityName = entityName;</span>

        // Configure using the default Hibernate configuration.
<span class="nc" id="L98">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L99">        configuration.configure();</span>

<span class="nc" id="L101">        this.sessionFactory = configuration.buildSessionFactory();</span>
<span class="nc" id="L102">    }</span>

    /**
     * Constructor which accepts an entityName and a Hibernate configuration
     * resource. The current implementation instantiates a SessionFactory per
     * instance (implying one instance per CacheStore-backed NamedCache).
     * @param entityName the Hibernate entity (i.e. the HQL table name)
     * @param resource the Hibernate config classpath resource (e.g. hibernate.cfg.xml)
     */
<span class="nc" id="L111">    public HibernateCacheLoader(String entityName, String resource) {</span>
<span class="nc" id="L112">        this.entityName = entityName;</span>

        /*
        If we start caching these we need to be aware that the resource may
        be relative (and so we should not key the cache by resource name).
        */
<span class="nc" id="L118">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L119">        configuration.configure(resource);</span>

<span class="nc" id="L121">        this.sessionFactory = configuration.buildSessionFactory();</span>
<span class="nc" id="L122">    }</span>

    /**
     * Constructor which accepts an entityName and a Hibernate configuration
     * resource. The current implementation instantiates a SessionFactory per
     * instance (implying one instance per CacheStore-backed NamedCache).
     * @param entityName the Hibernate entity (i.e. the HQL table name)
     * @param configurationFile the Hibernate config file (e.g. hibernate.cfg.xml)
     */
<span class="nc" id="L131">    public HibernateCacheLoader(String entityName, File configurationFile) {</span>
<span class="nc" id="L132">        this.entityName = entityName;</span>

        /*
        If we start caching these we should cache by canonical file name.
        */
<span class="nc" id="L137">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L138">        configuration.configure(configurationFile);</span>

<span class="nc" id="L140">        this.sessionFactory = configuration.buildSessionFactory();</span>
<span class="nc" id="L141">    }</span>

    /**
     * Constructor which accepts an entityName and a Hibernate {@code SessionFactory}.
     * This allows for external configuration of the SessionFactory (for instance using Spring).
     * @param entityName the Hibernate entity (i.e. the HQL table name)
     * @param sessionFactory the Hibernate SessionFactory
     */
<span class="nc" id="L149">    public HibernateCacheLoader(String entityName, SessionFactory sessionFactory) {</span>
<span class="nc" id="L150">        this.entityName = entityName;</span>
<span class="nc" id="L151">        this.sessionFactory = sessionFactory;</span>
<span class="nc" id="L152">    }</span>


    // ----- accessors -----------------------------------------------------

    /**
     * Get the Hibernate SessionFactory.
     * @return the Hibernate SessionFactory
     */
    public synchronized SessionFactory getSessionFactory() {
<span class="nc" id="L162">        return this.sessionFactory;</span>
    }

    /**
     * Set the Hibernate SessionFactory to be used by this CacheLoader.  This
     * attribute can only be set once during the lifecycle of an instance.
     * @param sessionFactory the Hibernate SessionFactory
     * @throws IllegalStateException  if the session factory has already been set
     */
    public synchronized void setSessionFactory(SessionFactory sessionFactory) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (this.sessionFactory != null) {</span>
<span class="nc" id="L173">            throw new IllegalStateException(&quot;SessionFactory has already been set&quot;);</span>
        }
<span class="nc" id="L175">        this.sessionFactory = sessionFactory;</span>
<span class="nc" id="L176">    }</span>

    /**
     * Get the Hibernate entity name.
     * @return the entity name
     */
    protected synchronized String getEntityName() {
<span class="nc" id="L183">        return this.entityName;</span>
    }

    /**
     * Set the Hibernate entity name. This attribute can only be set once
     * during the lifecycle of an instance.
     * @param entityName the entity name
     * @throws IllegalStateException if the entity name has already been set
     */
    public synchronized void setEntityName(String entityName) {
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (this.entityName != null) {</span>
<span class="nc" id="L194">            throw new IllegalStateException(&quot;Entity name has already been set&quot;);</span>
        }
<span class="nc" id="L196">        this.entityName = entityName;</span>
<span class="nc" id="L197">    }</span>

    // ----- Initialization methods ----------------------------------------

    /**
     * Initializer (must be called post-constructor).
     * &lt;p&gt;
     * We do this specifically so that derived classes can safely create
     * override methods that depend on a fully constructed object state.
     * Will only be called once per instance and prior to the main body
     * of any API methods. This should not be directly called by derived
     * classes. If this method is overridden, super must be called at the
     * end of the overriding method.
     */
    protected void initialize() {

<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (this.entityName == null) {</span>
<span class="nc" id="L214">            throw new IllegalStateException(&quot;Entity name attribute was not set&quot;);</span>
        }

<span class="nc" id="L217">        final SessionFactory sessionFactory = getSessionFactory();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (sessionFactory == null) {</span>
            // Can only occur with derived classes
<span class="nc" id="L220">            throw new IllegalStateException(&quot;No session factory was specified, &quot; +</span>
                    &quot;and a hibernate configuration file was not provided.&quot;);
        }

        // Look up the Hibernate metadata for the entity
<span class="nc" id="L225">        final MappingMetamodel metamodel = (MappingMetamodel) sessionFactory.getMetamodel();</span>
        try {
<span class="nc" id="L227">            final EntityPersister entityPersister = metamodel.getEntityDescriptor(this.entityName);</span>
<span class="nc" id="L228">            setEntityClassMetadata(entityPersister);</span>
        }
<span class="nc" id="L230">        catch (UnknownEntityTypeException ex) {</span>
<span class="nc" id="L231">            throw new RuntimeException(&quot;Unable to find ClassMetadata&quot; +</span>
                    &quot; for Hibernate entity &quot; + this.entityName + &quot;.&quot;);
<span class="nc" id="L233">        }</span>
<span class="nc" id="L234">    }</span>

    /**
     * Called by all API-implementing methods for lazy initialization. This
     * should never be called from a constructor.
     */
    protected synchronized void ensureInitialized() {
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (!this.initialized) {</span>
<span class="nc" id="L242">            initialize();</span>
<span class="nc" id="L243">            this.initialized = true;</span>
        }
<span class="nc" id="L245">    }</span>


    // ----- CacheLoader API methods ----------------------------------------

    /**
     * Load a Hibernate entity given an id (key).
     * @param key the cache key; specifically, the entity id
     * @return the corresponding Hibernate entity instance
     */
    public Object load(Object key) {
<span class="nc" id="L256">        ensureInitialized();</span>

<span class="nc" id="L258">        Transaction transaction = null;</span>

<span class="nc" id="L260">        Object value = null;</span>

<span class="nc" id="L262">        final Session session = openSession();</span>

        try {
<span class="nc" id="L265">            transaction = session.beginTransaction();</span>

            // The Hibernate docs indicate that the returned value is
            // sufficiently &quot;detached&quot; for our purposes (without explicitly
            // converting the state to transient).
<span class="nc" id="L270">            value = session.get(getEntityName(), (Serializable) key);</span>

<span class="nc" id="L272">            transaction.commit();</span>
        }
<span class="nc" id="L274">        catch (Exception ex) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (transaction != null) {</span>
<span class="nc" id="L276">                transaction.rollback();</span>
            }

<span class="nc" id="L279">            throw ensureRuntimeException(ex);</span>
        }
        finally {
<span class="nc" id="L282">            closeSession(session);</span>
        }

<span class="nc" id="L285">        return value;</span>
    }

    /**
     * Load a collection of Hibernate entities given a set of ids (keys).
     * @param keys the cache keys; specifically, the entity ids. By default, entities will be returned in the order of the
     *              provided List of keys
     * @return the corresponding Hibernate entity instances
     */
    public Map loadAll(List keys) {
<span class="nc" id="L295">        ensureInitialized();</span>

<span class="nc" id="L297">        final Map results = new HashMap();</span>

<span class="nc" id="L299">        Transaction transaction = null;</span>

<span class="nc" id="L301">        final Session session = openSession();</span>
<span class="nc" id="L302">        final SessionImplementor sessionImplementor = (SessionImplementor) session;</span>

        try {
<span class="nc" id="L305">            transaction = session.beginTransaction();</span>

            final List&lt;?&gt; result;
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (this.getLoadAllQuery() != null) {</span>
                // Create the query
<span class="nc" id="L310">                final String sQuery = getLoadAllQuery();</span>
<span class="nc" id="L311">                final Query query = session.createQuery(sQuery);</span>

                // Prevent Hibernate from caching the results
<span class="nc" id="L314">                query.setCacheMode(CacheMode.IGNORE);</span>
<span class="nc" id="L315">                query.setCacheable(false);</span>
<span class="nc" id="L316">                query.setReadOnly(true);</span>

                // Parameterize the query (where :keys = keys)
<span class="nc" id="L319">                query.setParameterList(PARAM_IDS, keys);</span>
<span class="nc" id="L320">                result = query.list();</span>
<span class="nc" id="L321">            }</span>
            else {
<span class="nc" id="L323">                result = session.byMultipleIds(this.entityName)</span>
<span class="nc" id="L324">                        .with(CacheMode.IGNORE)</span>
<span class="nc" id="L325">                        .multiLoad(keys);</span>
            }

            // Need a way to extract the key from an entity that we know
            // nothing about.
<span class="nc" id="L330">            final EntityPersister entityPersister = getEntityClassMetadata();</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (Object entity : result) {</span>
<span class="nc" id="L333">                final Object[] propertyValues = entityPersister.getValues(entity);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                for (Object propertyValue : propertyValues) {</span>
<span class="nc" id="L335">                    Hibernate.initialize(propertyValue);</span>
                }
<span class="nc" id="L337">            }</span>

            // Iterate through the results and place into the return map
<span class="nc bnc" id="L340" title="All 2 branches missed.">            for (Object entity : result) {</span>
<span class="nc" id="L341">                final Object id = entityPersister.getIdentifier(entity, sessionImplementor);</span>
<span class="nc" id="L342">                results.put(id, entity);</span>
<span class="nc" id="L343">            }</span>
<span class="nc" id="L344">            transaction.commit();</span>
        }
<span class="nc" id="L346">        catch (Exception ex) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (transaction != null) {</span>
<span class="nc" id="L348">                transaction.rollback();</span>
            }
<span class="nc" id="L350">            throw ensureRuntimeException(ex);</span>
        }
        finally {
<span class="nc" id="L353">            closeSession(session);</span>
        }

<span class="nc" id="L356">        return results;</span>
    }

    // ----- Helper methods -------------------------------------------------

    /**
     * Open a Hibernate Session.
     * @return the Hibernate Session object
     */
    protected Session openSession() {
<span class="nc" id="L366">        return getSessionFactory().openSession();</span>
    }

    /**
     * Close a Hibernate Session.
     * @param session the Hibernate Session object
     */
    protected void closeSession(Session session) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        azzert(session != null, &quot;Attempted to close a null session.&quot;);</span>
<span class="nc" id="L375">        session.close();</span>
<span class="nc" id="L376">    }</span>

    /**
     * Get the Hibernate ClassMetadata for the Hibernate entity.
     * @return the ClassMetadata object
     */
    protected EntityPersister getEntityClassMetadata() {
<span class="nc" id="L383">        return this.entityClassMetadata;</span>
    }

    /**
     * Get the Hibernate EntityPersister for the Hibernate entity.
     * @param entityPersister the EntityPersister object
     */
    protected void setEntityClassMetadata(EntityPersister entityPersister) {
<span class="nc" id="L391">        this.entityClassMetadata = entityPersister;</span>
<span class="nc" id="L392">    }</span>

    /**
     * Get the parameterized loadAll HQL query string.
     * @return  a parameterized HQL query string
     */
    protected String getLoadAllQuery() {
<span class="nc" id="L399">        return this.loadAllQuery;</span>
    }

    /**
     * Get the parameterized loadAll HQL query string.
     * @param sLoadAllQuery a parameterized HQL query string
     */
    protected void setLoadAllQuery(String sLoadAllQuery) {
<span class="nc" id="L407">        this.loadAllQuery = sLoadAllQuery;</span>
<span class="nc" id="L408">    }</span>

    /**
     * Create a transient entity instance given an entity id.
     * @param id the Hibernate entity id
     * @param sessionImplementor the Hibernate SessionImplementor
     * @return the Hibernate entity (may return null)
     */
    protected Object createEntityFromId(Object id, SharedSessionContractImplementor sessionImplementor) {
<span class="nc" id="L417">        final EntityPersister cmd = getEntityClassMetadata();</span>
<span class="nc" id="L418">        final Object o = cmd.instantiate(id, sessionImplementor);</span>
<span class="nc" id="L419">        return o;</span>
    }

    /**
     * Ensure that there are no conflicts between an explicit and implicit key.
     * @param id the explicit key
     * @param entity an entity (containing an implicit key)
     * @param sessionImplementor the Hibernate SessionImplementor
     */
    protected void validateIdentifier(Serializable id, Object entity, SharedSessionContractImplementor sessionImplementor) {
<span class="nc" id="L429">        final EntityPersister classMetaData = getEntityClassMetadata();</span>

<span class="nc" id="L431">        final Object intrinsicIdentifier =</span>
<span class="nc" id="L432">                classMetaData.getIdentifier(entity, sessionImplementor);</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (intrinsicIdentifier == null) {</span>
<span class="nc" id="L435">            classMetaData</span>
<span class="nc" id="L436">                    .setIdentifier(entity, id, sessionImplementor);</span>
        }
        else {
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (!intrinsicIdentifier.equals(id)) {</span>
<span class="nc" id="L440">                throw new IllegalArgumentException(&quot;Conflicting identifier &quot; +</span>
                        &quot;information between entity &quot; + entity + &quot; and id &quot; + id);
            }
        }
<span class="nc" id="L444">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>