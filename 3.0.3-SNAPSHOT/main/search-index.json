{
    "docs": [
        {
            "location": "/dev/02_source-code",
            "text": " The Source Code for Coherence Hibernate is hosted on github.com . It is located here: https://github.com/coherence-community/coherence-hibernate Alternatively, if you&#8217;re not using or want to avoid setting up git , you can download a zip containing the latest development branch from here: https://github.com/coherence-community/coherence-hibernate/archive/main.zip Important Pull Requests are welcome! Just make sure to become an official contributor . ",
            "title": "Source Code"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " We provide dedicated releases of the Hibernate Second-Level Cache implementations for Oracle Coherence depending on the Hibernate versions. The following versions are supported: Module Name Supported Hibernate Versions coherence-hibernate-cache-6 6.1.x , 6.2.x coherence-hibernate-cache-53 5.6.x Active development (new features) focuses on the coherence-hibernate-cache-6 module. This module also supports the latest stable release version of Hibernate 6.2.x . ",
            "title": "Supported Hibernate Versions"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " The minimum Coherence version that is supported by Coherence Hibernate is 23.03 (CE). We do recommend using the latest version of Coherence if possible. ",
            "title": "Supported Coherence Versions"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Using Coherence as a Hibernate second-level cache implementation allows multiple JVMs running the same Hibernate application to share a second-level cache. The use of Coherence caches in this scenario is completely controlled by Hibernate. You should have a good understanding of Hibernate second-level caching to successfully use the Coherence Hibernate second-level cache implementation. For more information on Hibernate second-level caching, see the relevant chapter on Caching in the Hibernate Core Reference Manual at http://www.hibernate.org/docs . Using Coherence as a Hibernate second-level cache implementation may be a good fit for Java applications that use Hibernate for data access and management, and that run in a cluster of application servers accessing the same database. Before you use the Coherence Hibernate Cache support, please also consider other caching strategies. Ultimately, you should make a decision that is most applicable to the needs of your application. ",
            "title": "Overview"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Installing the Coherence Hibernate second-level cache implementation amounts to obtaining a distribution of coherence-hibernate-cache-xx-3.0.3-SNAPSHOT.jar for the respective Hibernate version of your application. The easiest way to do so is to build and execute your Hibernate application with Maven, and add the following dependency to your application&#8217;s pom.xml : <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.hibernate&lt;/groupId&gt; &lt;artifactId&gt;coherence-hibernate-cache-6&lt;/artifactId&gt; &lt;version&gt;3.0.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; Alternatively, you can download coherence-hibernate-cache-6-3.0.3-SNAPSHOT.jar from a Maven repository (e.g. https://repo1.maven.org/maven2/ ) and use it in JVM classpaths. Or you can build the Coherence Hibernate second-level cache implementation from sources. Coherence Hibernate depends on Oracle Coherence (E.g. Coherence CE (Community Edition)) and Hibernate. These dependencies must be declared explicitly as we do not include them transitively. A full dependency declaration may look like the following: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.hibernate&lt;/groupId&gt; &lt;artifactId&gt;coherence-hibernate-cache-6&lt;/artifactId&gt; &lt;version&gt;3.0.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.6.15.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence&lt;/artifactId&gt; &lt;version&gt;23.09.2&lt;/version&gt; &lt;/dependency&gt; In the GitHub repository under samples, you will find a Spring Boot-based application that using Coherence Hibernate. Please see the respective README for details. ",
            "title": "Getting Started"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Familiarize yourself with the Coherence Documentation, especially the chapter on Performing Basic Cache Operations as it also details the Requirements for Cached Objects : Cache keys and values must be serializable (for example, java.io.Serializable or Coherence Portable Object Format (POF) serialization). Furthermore, cache keys must provide an implementation of hashCode() and equals() Those methods must return consistent results across cluster nodes. This implies that the implementation of hashCode() and equals() must be based solely on the object&#8217;s serializable state (that is, the object&#8217;s non-transient fields). Most built-in Java types, such as String , Integer and Date , meet this requirement. Some cache implementations (specifically the partitioned cache) use the serialized form of the key objects for equality testing, which means that keys for which equals() returns true must serialize identically. Most built-in Java types meet this requirement as well. ",
            "title": "Serialization Requirements"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " By default, Coherence Hibernate uses the DefaultCacheKeysFactory . When using Hibernate 5.2 or later, you can customize the used CacheKeysFactory using the Hibernate property: hibernate.cache.keys_factory You can specify the following values: default , which wraps identifiers in the tuple ( DefaultCacheKeysFactory ) simple , uses identifiers as keys without any wrapping ( SimpleCacheKeysFactory ) fully qualified class name that implements org.hibernate.cache.spi.CacheKeysFactory Hibernate versions before 5.3.0 have issues with composite keys, when using the DefaultCacheKeysFactory . If you need to use composite keys, please consider using the SimpleCacheKeysFactory instead. ",
            "title": "Cache Keys"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Both the clients of the Coherence Hibernate second-level caches&#8201;&#8212;&#8201;e.g. application server JVMs running Hibernate-based applications&#8201;&#8212;&#8201;and the Coherence cache server JVMs actually holding the cache contents need to have a common set of jar file artifacts available to their ClassLoaders. Specifically, both need coherence-hibernate-cache-xx-3.0.3-SNAPSHOT.jar and its dependencies Coherence and Hibernate (and their dependencies). The Coherence cache server JVMs need the Hibernate core jar file to deserialize CacheEntry classes ( org.hibernate.cache.spi.entry.* ) since the Coherence Hibernate second-level cache implementation uses Coherence EntryProcessors to optimize concurrency control. However, the cache server JVMs do not need the Hibernate application&#8217;s jar files containing entity classes etc. The client / application server JVMs do of course need the Hibernate application&#8217;s jar files containing entity classes etc. When configuring Coherence you should also consider the following two points in regard to storage-enabled cache server JVMs: If there is no separate tier of storage-enabled cache server JVMs in the Coherence cluster, then having application JVMs be storage-enabled is feasible, at the cost of increased heap utilization (by second-level cache contents) in those JVMs If there is a separate tier of storage-enabled cache server JVMs in the Coherence cluster, then application JVMs should be storage-disabled cluster members or remote clients of Coherence*Extend or gRPC proxy servers. See the comments in the default hibernate-second-level-cache-config.xml for details on how to accomplish the relevant configuration. It amounts to enabling/disabling local storage by making changes to the cache configuration files, or by passing â€“Dtangosol.coherence.distributed.localstorage=false to client JVMs. As of Coherence Hibernate 2.1.0 and using the coherence-hibernate-cache-53 module, you can specify Coherence property overrides via Hibernate properties. E.g. com.oracle.coherence.hibernate.cache.coherence_properties.tangosol.coherence.distributed.localstorage=false Both client and server JVMs will need the same Coherence operational configuration specifying necessary cluster communication parameters. See the chapter on Understanding Configuration in the reference documentation. Coherence provides default operational configuration, but it is a best practice to override communication parameters and cluster name to make them unique for each separate application environment. ",
            "title": "Configuring Clients and Servers for Hibernate Second-Level Caching"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " To configure Coherence as the Hibernate second-level cache, set the hibernate.cache.region.factory_class property in Hibernate configuration to com.oracle.coherence.hibernate.cache.v53.CoherenceRegionFactory . For example, include the following property setting in hibernate.cfg.xml : <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.region.factory_class\"&gt; com.oracle.coherence.hibernate.cache.v6.CoherenceRegionFactory &lt;/property&gt; In addition to setting the hibernate.cache.region.factory_class property, you must also configure Hibernate to use second-level caching by setting the appropriate Hibernate configuration property to true , as follows: <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.use_second_level_cache\"&gt;true&lt;/property&gt; Furthermore, you must configure each entity class mapped by Hibernate, and each Collection-typed field mapped by Hibernate, to use caching on a case-by-case basis. To configure mapped classes and Collection-typed fields to use second-level caching, add &lt;cache&gt; elements to the class&#8217;s mapping file as in the following example: <markup lang=\"xml\" >&lt;hibernate-mapping package=\"org.hibernate.tutorial.domain\"&gt; &lt;class name=\"Person\" table=\"PEOPLE\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;id name=\"id\" column=\"PERSON_ID\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"age\"/&gt; &lt;property name=\"firstname\"/&gt; &lt;property name=\"lastname\"/&gt; &lt;set name=\"events\" table=\"PERSON_EVENT\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;key column=\"PERSON_ID\"/&gt; &lt;many-to-many column=\"EVENT_ID\" class=\"Event\"/&gt; &lt;/set&gt; &lt;set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;key column=\"PERSON_ID\"/&gt; &lt;element type=\"string\" column=\"EMAIL_ADDR\"/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; The possible values for the usage attribute of the cache element are as follows: <markup lang=\"xml\" >&lt;cache usage=\"transactional | read-write | nonstrict-read-write | read-only\" /&gt; Alternatively, you can use the equivalent JPA annotations such as in the following example: <markup lang=\"java\" >@Entity @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) @Table(name=\"PEOPLE\") public class Person { // ... } The meaning and effect of each possible value is documented below in the section on cache concurrency strategies. ",
            "title": "Hibernate Second-Level Cache"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " When configuring query caching, you must again set the Hibernate property hibernate.cache.region.factory_class property. Furthermore, you must also configure Hibernate to enable query caching by setting the following Hibernate configuration property to true : <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.use_query_cache\"&gt;true&lt;/property&gt; Moreover, you must call setCacheable(true) , on each org.hibernate.Query executed by your application code, as in the following example: <markup lang=\"java\" >public List listPersons() { Session session = HibernateUtil.getSessionFactory().getCurrentSession(); session.beginTransaction(); Query query = session.createQuery(\"from Person\"); query.setCacheable(true); List result = query.list(); session.getTransaction().commit(); return result; } ",
            "title": "Hibernate Query Cache"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Hibernate uses three forms of caching: Session cache Second-level cache Query cache The session cache caches entities within a Hibernate Session. A Hibernate Session is a transaction-level cache of persistent data, potentially spanning multiple database transactions, and typically scoped on a per-thread basis. As a non-clustered cache, the session cache is managed entirely by Hibernate. The second-level and query caches span multiple transactions, and support the use of Coherence as a cache provider. The second-level cache is responsible for caching records across multiple Sessions (for primary key lookups). The query cache caches the result sets generated by Hibernate queries. Hibernate manages data in an internal representation in the second-level and query caches, meaning that these caches are usable only by Hibernate. For more information, see the chapter on Caching of the Hibernate Core Reference Manual. Hibernate Second-Level Cache To configure Coherence as the Hibernate second-level cache, set the hibernate.cache.region.factory_class property in Hibernate configuration to com.oracle.coherence.hibernate.cache.v53.CoherenceRegionFactory . For example, include the following property setting in hibernate.cfg.xml : <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.region.factory_class\"&gt; com.oracle.coherence.hibernate.cache.v6.CoherenceRegionFactory &lt;/property&gt; In addition to setting the hibernate.cache.region.factory_class property, you must also configure Hibernate to use second-level caching by setting the appropriate Hibernate configuration property to true , as follows: <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.use_second_level_cache\"&gt;true&lt;/property&gt; Furthermore, you must configure each entity class mapped by Hibernate, and each Collection-typed field mapped by Hibernate, to use caching on a case-by-case basis. To configure mapped classes and Collection-typed fields to use second-level caching, add &lt;cache&gt; elements to the class&#8217;s mapping file as in the following example: <markup lang=\"xml\" >&lt;hibernate-mapping package=\"org.hibernate.tutorial.domain\"&gt; &lt;class name=\"Person\" table=\"PEOPLE\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;id name=\"id\" column=\"PERSON_ID\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"age\"/&gt; &lt;property name=\"firstname\"/&gt; &lt;property name=\"lastname\"/&gt; &lt;set name=\"events\" table=\"PERSON_EVENT\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;key column=\"PERSON_ID\"/&gt; &lt;many-to-many column=\"EVENT_ID\" class=\"Event\"/&gt; &lt;/set&gt; &lt;set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;key column=\"PERSON_ID\"/&gt; &lt;element type=\"string\" column=\"EMAIL_ADDR\"/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; The possible values for the usage attribute of the cache element are as follows: <markup lang=\"xml\" >&lt;cache usage=\"transactional | read-write | nonstrict-read-write | read-only\" /&gt; Alternatively, you can use the equivalent JPA annotations such as in the following example: <markup lang=\"java\" >@Entity @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) @Table(name=\"PEOPLE\") public class Person { // ... } The meaning and effect of each possible value is documented below in the section on cache concurrency strategies. Hibernate Query Cache When configuring query caching, you must again set the Hibernate property hibernate.cache.region.factory_class property. Furthermore, you must also configure Hibernate to enable query caching by setting the following Hibernate configuration property to true : <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.use_query_cache\"&gt;true&lt;/property&gt; Moreover, you must call setCacheable(true) , on each org.hibernate.Query executed by your application code, as in the following example: <markup lang=\"java\" >public List listPersons() { Session session = HibernateUtil.getSessionFactory().getCurrentSession(); session.beginTransaction(); Query query = session.createQuery(\"from Person\"); query.setCacheable(true); List result = query.list(); session.getTransaction().commit(); return result; } ",
            "title": "Configuring Hibernate Second-Level and Query Caching"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Hibernate&#8217;s second-level cache design utilizes five different types of second-level cache, as reflected in the names of sub-interfaces of org.hibernate.cache.spi.Region : EntityRegions cache the data of entity instances mapped by Hibernate. By default Hibernate uses the fully-qualified name of the entity class as the name of an EntityRegion cache; though the name can be overridden through configuration. CollectionRegions cache the data of Collection-typed fields of mapped entities. Hibernate names CollectionRegion caches using the fully-qualified name of the entity class followed by the name of the Collection-typed field, separated by a period. NaturalIdRegions cache mappings of secondary identifiers to primary identifiers for entities. QueryResultsRegions cache the result sets of queries executed by Hibernate. Cache keys are formed using the query string and parameters, and cache values are collections of identifiers of entities satisfying the query. By default Hibernate uses one QueryResultsRegion with the name \" org.hibernate.cache.internal.StandardQueryCache \". Hibernate users can instantiate QueryResultsRegions by calling org.hibernate.Query.setCacheRegion() passing custom cache names (by convention these names should begin with \" query. \"). TimestampsRegions cache timestamps at which database tables were last written by Hibernate. These timestamps are used by Hibernate during query processing to determine whether cached query results can be used (if a query involves a certain table, and that table was written more recently than when the result set for that query was last cached, then the cached result set may be stale and cannot be used). Hibernate uses one TimestampsRegion named &#8220;`org.hibernate.cache.spi.UpdateTimestampsCache`&#8221;. The keys in this cache are database table names, and the values are machine clock readings. EntityRegions , CollectionRegions , and NaturalIdRegions are treated by Hibernate as &#8220;transactional&#8221; cache regions, meaning that the full variety of cache concurrency strategies may be configured (see the next section). Whereas QueryResultsRegions and TimestampsRegions are used by Hibernate as &#8220;general data&#8221; regions, rendering cache concurrency strategies irrelevant for those types of caches. ",
            "title": "Types of Hibernate Second-Level Cache"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " The Hibernate cache architecture defines four different \"cache concurrency strategies\" in association with its second-level cache. These are intended to allow Hibernate users to configure the degree of database consistency and transaction isolation desired for second-level cache contents, for data concurrently read and written through Hibernate. The following table describes the four Hibernate second-level cache concurrency strategies: Strategy Intent Write Transaction Sequence transactional Guarantee cache consistency with database, and repeatable read isolation, via JTA transactions enlisting both as resources. Cache and database committed atomically in same JTA transaction. read/write Maintain strong consistency with database, and read committed isolation in second-level cache. Database committed first, then cache updated using locking model. nonstrict read/write Better performance, but no guarantee of consistency with database or read committed isolation in second-level cache. Database committed first, then cache invalidated to cause subsequent read-through. read only Best performance for read-only data. Not applicable. For EntityRegions , CollectionRegions , and NaturalIdRegions , the appropriate cache concurrency strategy can be configured via the usage attribute of the cache element in the Hibernate mapping file for a mapped entity class, or via equivalent annotation. The Coherence Hibernate second-level cache implementation does not support the transactional cache concurrency strategy. ",
            "title": "Cache Concurrency Strategies"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " By default, the Coherence Hibernate second-level cache implementation uses a cache configuration file named hibernate-second-level-cache-config.xml at the root level in coherence-hibernate-cache-53-3.0.3-SNAPSHOT.jar . This configuration file defines cache mappings for Hibernate second-level caches. You can specify an alternative cache configuration file for Hibernate second-level caches using the Hibernate or Java property com.oracle.coherence.hibernate.cache.v53.cache_config_file_path , whose value should be the path to a file or ClassLoader resource, or a file:// URL. In fact, it is recommended and expected that you specify an alternative cache configuration file customized for the domain model and consistency / isolation requirements of your particular Hibernate application. For each mapped entity class and Collection-typed field, it is recommended that you configure an explicit cache mapping to the scheme (with expiry and size parameters) appropriate for that cache given application requirements. See comments in the default cache configuration file for more detail on customizing cache configuration for your application. The default cache configuration file takes a conservative approach, and it is likely that you can optimize cache access latency and hit ratio (via size) for entity and collection caches with relaxed consistency / isolation requirements. In any case, it is recommended that you configure dedicated cache services for Hibernate second-level caches (as is done in the default cache configuration file), to avoid the potential for reentrant calls into cache services when Hibernate-based CacheStores are used. Furthermore, second-level caches should be size-limited in all tiers to avoid the possibility of heap exhaustion. Query caches in particular should be size-limited because the Hibernate API does not provide any means of controlling the query cache other than a complete eviction. Finally, expiration should be considered if the underlying database can be written by clients other than the Hibernate application. ",
            "title": "Coherence Cache Configuration"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Property com.oracle.coherence.hibernate.cache.session_name allows to specify a name for the underlying Coherence session. If not specified, the default session name will be used. Requires Coherence 21.12 or higher. ",
            "title": "Session Name 5.3+ "
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Using property com.oracle.coherence.hibernate.cache.session_type you can specify the type of the session. By default, the session type is server which means that the Coherence Hibernate application becomes a node in the Coherence cluster using the Tangosol Cluster Management Protocol (TCMP). Please see the chapter Introduction to Coherence Clusters of the Coherence reference guide for more details. Client Server (default) If, on the other hand, you would like to connect to Coherence in strict client mode using either Coherence*Extend or gRPC, you will need to set the session type to client . In that case, the Coherence Hibernate application will not use TCMP. When using Coherence Hibernate in pure client mode, please also set the Coherence property coherence.tcmp.enabled to false , either via System property of the custom Hibernate property: com.oracle.coherence.hibernate.cache.coherence_properties.coherence.tcmp.enabled: false . ",
            "title": "Session Type 5.3+ "
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " By default, Coherence Hibernate starts a minimal Coherence cluster node without starting any additional services. Since Coherence Hibernate 5.3.1 , we also provide an option to start Coherence using the DefaultCacheServer . That way a fully featured Coherence Cluster node is started, allowing for the configuration of e.g. Management over REST, which allows for the convenient introspection of the Cluster node and its caches using the Coherence CLI . This option is ignored if you set com.oracle.coherence.hibernate.cache.session_type to client . ",
            "title": "Start full Cache Server 5.3+"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Hibernate provides the configuration property hibernate.cache.use_minimal_puts , which optimizes cache management for clustered caches by minimizing cache update operations. The Coherence caching provider enables this by default. Setting this property to false might increase overhead for cache management. ",
            "title": "Minimal Puts"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " When providing Hibernate properties, you can also specify any Coherence system property overrides using the following property structure: <markup lang=\"properties\" >com.oracle.coherence.hibernate.cache.coherence_properties.*=my property value Specifying Coherence-specific properties is available for the Hibernate Cache 53 module only! For instance, in order to redirect the logging output of Coherence (Only Coherence!) to its own log file, and setting the log level to maximum, you could specify: <markup lang=\"properties\" >com.oracle.coherence.hibernate.cache.coherence_properties.coherence.log=/path/to/coherence.log com.oracle.coherence.hibernate.cache.coherence_properties.coherence.log.level: 9 ",
            "title": "Coherence-specific properties 5.3+ "
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Without specifying any custom logging properties, Coherence Hibernate will set the logger of Coherence to slf4j . Therefore, Coherence Hibernate should integrate seamlessly into your application out of the box. Under the covers, Coherence Hibernate is configured using a custom implementation of a Coherence SystemPropertyResolver . Note Properties defined via Operational Override Files take precedence. For example, if your application provides a custom tangosol-coherence-override.xml file, such as the following, then providing a respective Coherence Hibernate property will not have any effect. <markup lang=\"xml\" >&lt;logging-config&gt; &lt;destination&gt;slf4j&lt;/destination&gt; &lt;/logging-config&gt; ",
            "title": "Logging 5.3+ "
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " Session Name 5.3+ Property com.oracle.coherence.hibernate.cache.session_name allows to specify a name for the underlying Coherence session. If not specified, the default session name will be used. Requires Coherence 21.12 or higher. Session Type 5.3+ Using property com.oracle.coherence.hibernate.cache.session_type you can specify the type of the session. By default, the session type is server which means that the Coherence Hibernate application becomes a node in the Coherence cluster using the Tangosol Cluster Management Protocol (TCMP). Please see the chapter Introduction to Coherence Clusters of the Coherence reference guide for more details. Client Server (default) If, on the other hand, you would like to connect to Coherence in strict client mode using either Coherence*Extend or gRPC, you will need to set the session type to client . In that case, the Coherence Hibernate application will not use TCMP. When using Coherence Hibernate in pure client mode, please also set the Coherence property coherence.tcmp.enabled to false , either via System property of the custom Hibernate property: com.oracle.coherence.hibernate.cache.coherence_properties.coherence.tcmp.enabled: false . Start full Cache Server 5.3+ By default, Coherence Hibernate starts a minimal Coherence cluster node without starting any additional services. Since Coherence Hibernate 5.3.1 , we also provide an option to start Coherence using the DefaultCacheServer . That way a fully featured Coherence Cluster node is started, allowing for the configuration of e.g. Management over REST, which allows for the convenient introspection of the Cluster node and its caches using the Coherence CLI . This option is ignored if you set com.oracle.coherence.hibernate.cache.session_type to client . Minimal Puts Hibernate provides the configuration property hibernate.cache.use_minimal_puts , which optimizes cache management for clustered caches by minimizing cache update operations. The Coherence caching provider enables this by default. Setting this property to false might increase overhead for cache management. Coherence-specific properties 5.3+ When providing Hibernate properties, you can also specify any Coherence system property overrides using the following property structure: <markup lang=\"properties\" >com.oracle.coherence.hibernate.cache.coherence_properties.*=my property value Specifying Coherence-specific properties is available for the Hibernate Cache 53 module only! For instance, in order to redirect the logging output of Coherence (Only Coherence!) to its own log file, and setting the log level to maximum, you could specify: <markup lang=\"properties\" >com.oracle.coherence.hibernate.cache.coherence_properties.coherence.log=/path/to/coherence.log com.oracle.coherence.hibernate.cache.coherence_properties.coherence.log.level: 9 Logging 5.3+ Without specifying any custom logging properties, Coherence Hibernate will set the logger of Coherence to slf4j . Therefore, Coherence Hibernate should integrate seamlessly into your application out of the box. Under the covers, Coherence Hibernate is configured using a custom implementation of a Coherence SystemPropertyResolver . Note Properties defined via Operational Override Files take precedence. For example, if your application provides a custom tangosol-coherence-override.xml file, such as the following, then providing a respective Coherence Hibernate property will not have any effect. <markup lang=\"xml\" >&lt;logging-config&gt; &lt;destination&gt;slf4j&lt;/destination&gt; &lt;/logging-config&gt; ",
            "title": "Additional Configuration Options"
        },
        {
            "location": "/about/02_hibernate-cache",
            "text": " This section describes how you can use Oracle Coherence as a second-level cache in Hibernate ORM , an object-relational mapping library for Java applications. Since version 2.1 (released December 11th 2003) Hibernate has incorporated second-level caching, by allowing an implementation of a Service Provider Interface (SPI) to be configured. In Hibernate version 3.3 (released September 11th 2008) the second-level cache SPI was significantly redesigned. Over the next couple of versions the SPI was further refined leading to breaking changes. Supported Hibernate Versions We provide dedicated releases of the Hibernate Second-Level Cache implementations for Oracle Coherence depending on the Hibernate versions. The following versions are supported: Module Name Supported Hibernate Versions coherence-hibernate-cache-6 6.1.x , 6.2.x coherence-hibernate-cache-53 5.6.x Active development (new features) focuses on the coherence-hibernate-cache-6 module. This module also supports the latest stable release version of Hibernate 6.2.x . Supported Coherence Versions The minimum Coherence version that is supported by Coherence Hibernate is 23.03 (CE). We do recommend using the latest version of Coherence if possible. Overview Using Coherence as a Hibernate second-level cache implementation allows multiple JVMs running the same Hibernate application to share a second-level cache. The use of Coherence caches in this scenario is completely controlled by Hibernate. You should have a good understanding of Hibernate second-level caching to successfully use the Coherence Hibernate second-level cache implementation. For more information on Hibernate second-level caching, see the relevant chapter on Caching in the Hibernate Core Reference Manual at http://www.hibernate.org/docs . Using Coherence as a Hibernate second-level cache implementation may be a good fit for Java applications that use Hibernate for data access and management, and that run in a cluster of application servers accessing the same database. Before you use the Coherence Hibernate Cache support, please also consider other caching strategies. Ultimately, you should make a decision that is most applicable to the needs of your application. Getting Started Installing the Coherence Hibernate second-level cache implementation amounts to obtaining a distribution of coherence-hibernate-cache-xx-3.0.3-SNAPSHOT.jar for the respective Hibernate version of your application. The easiest way to do so is to build and execute your Hibernate application with Maven, and add the following dependency to your application&#8217;s pom.xml : <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.hibernate&lt;/groupId&gt; &lt;artifactId&gt;coherence-hibernate-cache-6&lt;/artifactId&gt; &lt;version&gt;3.0.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; Alternatively, you can download coherence-hibernate-cache-6-3.0.3-SNAPSHOT.jar from a Maven repository (e.g. https://repo1.maven.org/maven2/ ) and use it in JVM classpaths. Or you can build the Coherence Hibernate second-level cache implementation from sources. Coherence Hibernate depends on Oracle Coherence (E.g. Coherence CE (Community Edition)) and Hibernate. These dependencies must be declared explicitly as we do not include them transitively. A full dependency declaration may look like the following: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.hibernate&lt;/groupId&gt; &lt;artifactId&gt;coherence-hibernate-cache-6&lt;/artifactId&gt; &lt;version&gt;3.0.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.6.15.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence&lt;/artifactId&gt; &lt;version&gt;23.09.2&lt;/version&gt; &lt;/dependency&gt; In the GitHub repository under samples, you will find a Spring Boot-based application that using Coherence Hibernate. Please see the respective README for details. Serialization Requirements Familiarize yourself with the Coherence Documentation, especially the chapter on Performing Basic Cache Operations as it also details the Requirements for Cached Objects : Cache keys and values must be serializable (for example, java.io.Serializable or Coherence Portable Object Format (POF) serialization). Furthermore, cache keys must provide an implementation of hashCode() and equals() Those methods must return consistent results across cluster nodes. This implies that the implementation of hashCode() and equals() must be based solely on the object&#8217;s serializable state (that is, the object&#8217;s non-transient fields). Most built-in Java types, such as String , Integer and Date , meet this requirement. Some cache implementations (specifically the partitioned cache) use the serialized form of the key objects for equality testing, which means that keys for which equals() returns true must serialize identically. Most built-in Java types meet this requirement as well. Cache Keys By default, Coherence Hibernate uses the DefaultCacheKeysFactory . When using Hibernate 5.2 or later, you can customize the used CacheKeysFactory using the Hibernate property: hibernate.cache.keys_factory You can specify the following values: default , which wraps identifiers in the tuple ( DefaultCacheKeysFactory ) simple , uses identifiers as keys without any wrapping ( SimpleCacheKeysFactory ) fully qualified class name that implements org.hibernate.cache.spi.CacheKeysFactory Hibernate versions before 5.3.0 have issues with composite keys, when using the DefaultCacheKeysFactory . If you need to use composite keys, please consider using the SimpleCacheKeysFactory instead. Configuring Clients and Servers for Hibernate Second-Level Caching Both the clients of the Coherence Hibernate second-level caches&#8201;&#8212;&#8201;e.g. application server JVMs running Hibernate-based applications&#8201;&#8212;&#8201;and the Coherence cache server JVMs actually holding the cache contents need to have a common set of jar file artifacts available to their ClassLoaders. Specifically, both need coherence-hibernate-cache-xx-3.0.3-SNAPSHOT.jar and its dependencies Coherence and Hibernate (and their dependencies). The Coherence cache server JVMs need the Hibernate core jar file to deserialize CacheEntry classes ( org.hibernate.cache.spi.entry.* ) since the Coherence Hibernate second-level cache implementation uses Coherence EntryProcessors to optimize concurrency control. However, the cache server JVMs do not need the Hibernate application&#8217;s jar files containing entity classes etc. The client / application server JVMs do of course need the Hibernate application&#8217;s jar files containing entity classes etc. When configuring Coherence you should also consider the following two points in regard to storage-enabled cache server JVMs: If there is no separate tier of storage-enabled cache server JVMs in the Coherence cluster, then having application JVMs be storage-enabled is feasible, at the cost of increased heap utilization (by second-level cache contents) in those JVMs If there is a separate tier of storage-enabled cache server JVMs in the Coherence cluster, then application JVMs should be storage-disabled cluster members or remote clients of Coherence*Extend or gRPC proxy servers. See the comments in the default hibernate-second-level-cache-config.xml for details on how to accomplish the relevant configuration. It amounts to enabling/disabling local storage by making changes to the cache configuration files, or by passing â€“Dtangosol.coherence.distributed.localstorage=false to client JVMs. As of Coherence Hibernate 2.1.0 and using the coherence-hibernate-cache-53 module, you can specify Coherence property overrides via Hibernate properties. E.g. com.oracle.coherence.hibernate.cache.coherence_properties.tangosol.coherence.distributed.localstorage=false Both client and server JVMs will need the same Coherence operational configuration specifying necessary cluster communication parameters. See the chapter on Understanding Configuration in the reference documentation. Coherence provides default operational configuration, but it is a best practice to override communication parameters and cluster name to make them unique for each separate application environment. Configuring Hibernate Second-Level and Query Caching Hibernate uses three forms of caching: Session cache Second-level cache Query cache The session cache caches entities within a Hibernate Session. A Hibernate Session is a transaction-level cache of persistent data, potentially spanning multiple database transactions, and typically scoped on a per-thread basis. As a non-clustered cache, the session cache is managed entirely by Hibernate. The second-level and query caches span multiple transactions, and support the use of Coherence as a cache provider. The second-level cache is responsible for caching records across multiple Sessions (for primary key lookups). The query cache caches the result sets generated by Hibernate queries. Hibernate manages data in an internal representation in the second-level and query caches, meaning that these caches are usable only by Hibernate. For more information, see the chapter on Caching of the Hibernate Core Reference Manual. Hibernate Second-Level Cache To configure Coherence as the Hibernate second-level cache, set the hibernate.cache.region.factory_class property in Hibernate configuration to com.oracle.coherence.hibernate.cache.v53.CoherenceRegionFactory . For example, include the following property setting in hibernate.cfg.xml : <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.region.factory_class\"&gt; com.oracle.coherence.hibernate.cache.v6.CoherenceRegionFactory &lt;/property&gt; In addition to setting the hibernate.cache.region.factory_class property, you must also configure Hibernate to use second-level caching by setting the appropriate Hibernate configuration property to true , as follows: <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.use_second_level_cache\"&gt;true&lt;/property&gt; Furthermore, you must configure each entity class mapped by Hibernate, and each Collection-typed field mapped by Hibernate, to use caching on a case-by-case basis. To configure mapped classes and Collection-typed fields to use second-level caching, add &lt;cache&gt; elements to the class&#8217;s mapping file as in the following example: <markup lang=\"xml\" >&lt;hibernate-mapping package=\"org.hibernate.tutorial.domain\"&gt; &lt;class name=\"Person\" table=\"PEOPLE\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;id name=\"id\" column=\"PERSON_ID\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"age\"/&gt; &lt;property name=\"firstname\"/&gt; &lt;property name=\"lastname\"/&gt; &lt;set name=\"events\" table=\"PERSON_EVENT\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;key column=\"PERSON_ID\"/&gt; &lt;many-to-many column=\"EVENT_ID\" class=\"Event\"/&gt; &lt;/set&gt; &lt;set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\"&gt; &lt;cache usage=\"read-write\" /&gt; &lt;key column=\"PERSON_ID\"/&gt; &lt;element type=\"string\" column=\"EMAIL_ADDR\"/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; The possible values for the usage attribute of the cache element are as follows: <markup lang=\"xml\" >&lt;cache usage=\"transactional | read-write | nonstrict-read-write | read-only\" /&gt; Alternatively, you can use the equivalent JPA annotations such as in the following example: <markup lang=\"java\" >@Entity @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) @Table(name=\"PEOPLE\") public class Person { // ... } The meaning and effect of each possible value is documented below in the section on cache concurrency strategies. Hibernate Query Cache When configuring query caching, you must again set the Hibernate property hibernate.cache.region.factory_class property. Furthermore, you must also configure Hibernate to enable query caching by setting the following Hibernate configuration property to true : <markup lang=\"xml\" >&lt;property name=\"hibernate.cache.use_query_cache\"&gt;true&lt;/property&gt; Moreover, you must call setCacheable(true) , on each org.hibernate.Query executed by your application code, as in the following example: <markup lang=\"java\" >public List listPersons() { Session session = HibernateUtil.getSessionFactory().getCurrentSession(); session.beginTransaction(); Query query = session.createQuery(\"from Person\"); query.setCacheable(true); List result = query.list(); session.getTransaction().commit(); return result; } Types of Hibernate Second-Level Cache Hibernate&#8217;s second-level cache design utilizes five different types of second-level cache, as reflected in the names of sub-interfaces of org.hibernate.cache.spi.Region : EntityRegions cache the data of entity instances mapped by Hibernate. By default Hibernate uses the fully-qualified name of the entity class as the name of an EntityRegion cache; though the name can be overridden through configuration. CollectionRegions cache the data of Collection-typed fields of mapped entities. Hibernate names CollectionRegion caches using the fully-qualified name of the entity class followed by the name of the Collection-typed field, separated by a period. NaturalIdRegions cache mappings of secondary identifiers to primary identifiers for entities. QueryResultsRegions cache the result sets of queries executed by Hibernate. Cache keys are formed using the query string and parameters, and cache values are collections of identifiers of entities satisfying the query. By default Hibernate uses one QueryResultsRegion with the name \" org.hibernate.cache.internal.StandardQueryCache \". Hibernate users can instantiate QueryResultsRegions by calling org.hibernate.Query.setCacheRegion() passing custom cache names (by convention these names should begin with \" query. \"). TimestampsRegions cache timestamps at which database tables were last written by Hibernate. These timestamps are used by Hibernate during query processing to determine whether cached query results can be used (if a query involves a certain table, and that table was written more recently than when the result set for that query was last cached, then the cached result set may be stale and cannot be used). Hibernate uses one TimestampsRegion named &#8220;`org.hibernate.cache.spi.UpdateTimestampsCache`&#8221;. The keys in this cache are database table names, and the values are machine clock readings. EntityRegions , CollectionRegions , and NaturalIdRegions are treated by Hibernate as &#8220;transactional&#8221; cache regions, meaning that the full variety of cache concurrency strategies may be configured (see the next section). Whereas QueryResultsRegions and TimestampsRegions are used by Hibernate as &#8220;general data&#8221; regions, rendering cache concurrency strategies irrelevant for those types of caches. Cache Concurrency Strategies The Hibernate cache architecture defines four different \"cache concurrency strategies\" in association with its second-level cache. These are intended to allow Hibernate users to configure the degree of database consistency and transaction isolation desired for second-level cache contents, for data concurrently read and written through Hibernate. The following table describes the four Hibernate second-level cache concurrency strategies: Strategy Intent Write Transaction Sequence transactional Guarantee cache consistency with database, and repeatable read isolation, via JTA transactions enlisting both as resources. Cache and database committed atomically in same JTA transaction. read/write Maintain strong consistency with database, and read committed isolation in second-level cache. Database committed first, then cache updated using locking model. nonstrict read/write Better performance, but no guarantee of consistency with database or read committed isolation in second-level cache. Database committed first, then cache invalidated to cause subsequent read-through. read only Best performance for read-only data. Not applicable. For EntityRegions , CollectionRegions , and NaturalIdRegions , the appropriate cache concurrency strategy can be configured via the usage attribute of the cache element in the Hibernate mapping file for a mapped entity class, or via equivalent annotation. The Coherence Hibernate second-level cache implementation does not support the transactional cache concurrency strategy. Coherence Cache Configuration By default, the Coherence Hibernate second-level cache implementation uses a cache configuration file named hibernate-second-level-cache-config.xml at the root level in coherence-hibernate-cache-53-3.0.3-SNAPSHOT.jar . This configuration file defines cache mappings for Hibernate second-level caches. You can specify an alternative cache configuration file for Hibernate second-level caches using the Hibernate or Java property com.oracle.coherence.hibernate.cache.v53.cache_config_file_path , whose value should be the path to a file or ClassLoader resource, or a file:// URL. In fact, it is recommended and expected that you specify an alternative cache configuration file customized for the domain model and consistency / isolation requirements of your particular Hibernate application. For each mapped entity class and Collection-typed field, it is recommended that you configure an explicit cache mapping to the scheme (with expiry and size parameters) appropriate for that cache given application requirements. See comments in the default cache configuration file for more detail on customizing cache configuration for your application. The default cache configuration file takes a conservative approach, and it is likely that you can optimize cache access latency and hit ratio (via size) for entity and collection caches with relaxed consistency / isolation requirements. In any case, it is recommended that you configure dedicated cache services for Hibernate second-level caches (as is done in the default cache configuration file), to avoid the potential for reentrant calls into cache services when Hibernate-based CacheStores are used. Furthermore, second-level caches should be size-limited in all tiers to avoid the possibility of heap exhaustion. Query caches in particular should be size-limited because the Hibernate API does not provide any means of controlling the query cache other than a complete eviction. Finally, expiration should be considered if the underlying database can be written by clients other than the Hibernate application. Additional Configuration Options Session Name 5.3+ Property com.oracle.coherence.hibernate.cache.session_name allows to specify a name for the underlying Coherence session. If not specified, the default session name will be used. Requires Coherence 21.12 or higher. Session Type 5.3+ Using property com.oracle.coherence.hibernate.cache.session_type you can specify the type of the session. By default, the session type is server which means that the Coherence Hibernate application becomes a node in the Coherence cluster using the Tangosol Cluster Management Protocol (TCMP). Please see the chapter Introduction to Coherence Clusters of the Coherence reference guide for more details. Client Server (default) If, on the other hand, you would like to connect to Coherence in strict client mode using either Coherence*Extend or gRPC, you will need to set the session type to client . In that case, the Coherence Hibernate application will not use TCMP. When using Coherence Hibernate in pure client mode, please also set the Coherence property coherence.tcmp.enabled to false , either via System property of the custom Hibernate property: com.oracle.coherence.hibernate.cache.coherence_properties.coherence.tcmp.enabled: false . Start full Cache Server 5.3+ By default, Coherence Hibernate starts a minimal Coherence cluster node without starting any additional services. Since Coherence Hibernate 5.3.1 , we also provide an option to start Coherence using the DefaultCacheServer . That way a fully featured Coherence Cluster node is started, allowing for the configuration of e.g. Management over REST, which allows for the convenient introspection of the Cluster node and its caches using the Coherence CLI . This option is ignored if you set com.oracle.coherence.hibernate.cache.session_type to client . Minimal Puts Hibernate provides the configuration property hibernate.cache.use_minimal_puts , which optimizes cache management for clustered caches by minimizing cache update operations. The Coherence caching provider enables this by default. Setting this property to false might increase overhead for cache management. Coherence-specific properties 5.3+ When providing Hibernate properties, you can also specify any Coherence system property overrides using the following property structure: <markup lang=\"properties\" >com.oracle.coherence.hibernate.cache.coherence_properties.*=my property value Specifying Coherence-specific properties is available for the Hibernate Cache 53 module only! For instance, in order to redirect the logging output of Coherence (Only Coherence!) to its own log file, and setting the log level to maximum, you could specify: <markup lang=\"properties\" >com.oracle.coherence.hibernate.cache.coherence_properties.coherence.log=/path/to/coherence.log com.oracle.coherence.hibernate.cache.coherence_properties.coherence.log.level: 9 Logging 5.3+ Without specifying any custom logging properties, Coherence Hibernate will set the logger of Coherence to slf4j . Therefore, Coherence Hibernate should integrate seamlessly into your application out of the box. Under the covers, Coherence Hibernate is configured using a custom implementation of a Coherence SystemPropertyResolver . Note Properties defined via Operational Override Files take precedence. For example, if your application provides a custom tangosol-coherence-override.xml file, such as the following, then providing a respective Coherence Hibernate property will not have any effect. <markup lang=\"xml\" >&lt;logging-config&gt; &lt;destination&gt;slf4j&lt;/destination&gt; &lt;/logging-config&gt; ",
            "title": "Coherence Hibernate Second-Level Cache"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v3.0.1 ",
            "title": "Version 3.0.1 (January 27, 2024)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v3.0.0 ",
            "title": "Version 3.0.0 (July 4, 2023)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.3 ",
            "title": "Version 2.3.3 (July 2, 2023)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.2 ",
            "title": "Version 2.3.2 (January 26, 2023)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.1 ",
            "title": "Version 2.3.1 (November 3, 2022)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.0 ",
            "title": "Version 2.3.0 (August 25, 2022)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.2.0 ",
            "title": "Version 2.2.0 (August, 2022)"
        },
        {
            "location": "/dev/06_history",
            "text": " https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.1.1 ",
            "title": "Version 2.1.1 (Jan, 2022)"
        },
        {
            "location": "/dev/06_history",
            "text": " Add sample application Require Java 11 to build the project. When solely using, Java 8 is still supported ",
            "title": "Global and Cross-Module Changes"
        },
        {
            "location": "/dev/06_history",
            "text": " Add support for configurable CacheKeysFactories in Hibernate 5.2.x Add support for Hibernate 5.3.x , 5.4.x , 5.5.x , 5.6.x ",
            "title": "coherence-hibernate-second-level-cache"
        },
        {
            "location": "/dev/06_history",
            "text": " Migrate to new website format Publish JavaDoc ",
            "title": "coherence-hibernate-site"
        },
        {
            "location": "/dev/06_history",
            "text": " Global and Cross-Module Changes Add sample application Require Java 11 to build the project. When solely using, Java 8 is still supported coherence-hibernate-second-level-cache Add support for configurable CacheKeysFactories in Hibernate 5.2.x Add support for Hibernate 5.3.x , 5.4.x , 5.5.x , 5.6.x coherence-hibernate-site Migrate to new website format Publish JavaDoc ",
            "title": "Version 2.1.0-M1 (Nov 2021)"
        },
        {
            "location": "/dev/06_history",
            "text": " Change licensing from the COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) to The Universal Permissive License (UPL) Updating of dependencies. Merge functional tests into the respective versions ",
            "title": "Global and Cross-Module Changes"
        },
        {
            "location": "/dev/06_history",
            "text": " Update dependencies ",
            "title": "coherence-hibernate-cache-store"
        },
        {
            "location": "/dev/06_history",
            "text": " Add support for Hibernate 4.3.x , 5.0.x , 5.1.x , 5.2.x Add additional modules for the various Hibernate versions ",
            "title": "coherence-hibernate-second-level-cache"
        },
        {
            "location": "/dev/06_history",
            "text": " Polishing and updating for 2.0.0 Update site code ",
            "title": "coherence-hibernate-site"
        },
        {
            "location": "/dev/06_history",
            "text": " Global and Cross-Module Changes Change licensing from the COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) to The Universal Permissive License (UPL) Updating of dependencies. Merge functional tests into the respective versions coherence-hibernate-cache-store Update dependencies coherence-hibernate-second-level-cache Add support for Hibernate 4.3.x , 5.0.x , 5.1.x , 5.2.x Add additional modules for the various Hibernate versions coherence-hibernate-site Polishing and updating for 2.0.0 Update site code ",
            "title": "Version 2.0.0 @ 2020-11-25 15:30"
        },
        {
            "location": "/dev/06_history",
            "text": " Randy Stafford ",
            "title": "Source and Documentation Contributors"
        },
        {
            "location": "/dev/06_history",
            "text": " Initial release. ",
            "title": "Global and Cross-Module Changes"
        },
        {
            "location": "/dev/06_history",
            "text": " Initial release. ",
            "title": "coherence-hibernate-cache-store"
        },
        {
            "location": "/dev/06_history",
            "text": " Initial release. ",
            "title": "coherence-hibernate-cache-store-tests"
        },
        {
            "location": "/dev/06_history",
            "text": " Initial release. ",
            "title": "coherence-hibernate-second-level-cache"
        },
        {
            "location": "/dev/06_history",
            "text": " Initial release. ",
            "title": "coherence-hibernate-second-level-cache-tests"
        },
        {
            "location": "/dev/06_history",
            "text": " Initial release. ",
            "title": "coherence-hibernate-site"
        },
        {
            "location": "/dev/06_history",
            "text": " Source and Documentation Contributors Randy Stafford Global and Cross-Module Changes Initial release. coherence-hibernate-cache-store Initial release. coherence-hibernate-cache-store-tests Initial release. coherence-hibernate-second-level-cache Initial release. coherence-hibernate-second-level-cache-tests Initial release. coherence-hibernate-site Initial release. ",
            "title": "Version 1.0.0 @ 2013-09-12 15:30"
        },
        {
            "location": "/dev/06_history",
            "text": " The following sections outline Oracle Coherence Hibernate Integration changes in reverse chronological order. Version 3.0.1 (January 27, 2024) https://github.com/coherence-community/coherence-hibernate/releases/tag/v3.0.1 Version 3.0.0 (July 4, 2023) https://github.com/coherence-community/coherence-hibernate/releases/tag/v3.0.0 Version 2.3.3 (July 2, 2023) https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.3 Version 2.3.2 (January 26, 2023) https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.2 Version 2.3.1 (November 3, 2022) https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.1 Version 2.3.0 (August 25, 2022) https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.3.0 Version 2.2.0 (August, 2022) https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.2.0 Version 2.1.1 (Jan, 2022) https://github.com/coherence-community/coherence-hibernate/releases/tag/v2.1.1 Version 2.1.0-M1 (Nov 2021) Global and Cross-Module Changes Add sample application Require Java 11 to build the project. When solely using, Java 8 is still supported coherence-hibernate-second-level-cache Add support for configurable CacheKeysFactories in Hibernate 5.2.x Add support for Hibernate 5.3.x , 5.4.x , 5.5.x , 5.6.x coherence-hibernate-site Migrate to new website format Publish JavaDoc Version 2.0.0 @ 2020-11-25 15:30 Global and Cross-Module Changes Change licensing from the COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) to The Universal Permissive License (UPL) Updating of dependencies. Merge functional tests into the respective versions coherence-hibernate-cache-store Update dependencies coherence-hibernate-second-level-cache Add support for Hibernate 4.3.x , 5.0.x , 5.1.x , 5.2.x Add additional modules for the various Hibernate versions coherence-hibernate-site Polishing and updating for 2.0.0 Update site code Version 1.0.0 @ 2013-09-12 15:30 Source and Documentation Contributors Randy Stafford Global and Cross-Module Changes Initial release. coherence-hibernate-cache-store Initial release. coherence-hibernate-cache-store-tests Initial release. coherence-hibernate-second-level-cache Initial release. coherence-hibernate-second-level-cache-tests Initial release. coherence-hibernate-site Initial release. ",
            "title": "Change History"
        },
        {
            "location": "/dev/05_contributions",
            "text": " We would love your contributions to the Coherence Hibernate project! ",
            "title": "Overview"
        },
        {
            "location": "/dev/05_contributions",
            "text": " The details of how to contribute to Coherence Hibernate are detailed in CONTRIBUTING.adoc in the Coherence Hibernate GitHub repository. ",
            "title": "Becoming a Contributor"
        },
        {
            "location": "/dev/05_contributions",
            "text": " The following sections outline the requirements for making contributions to the Coherence Hibernate project. Overview We would love your contributions to the Coherence Hibernate project! Becoming a Contributor The details of how to contribute to Coherence Hibernate are detailed in CONTRIBUTING.adoc in the Coherence Hibernate GitHub repository. ",
            "title": "Contributing"
        },
        {
            "location": "/dev/01_license",
            "text": " Subject to the condition set forth below, permission is hereby granted to any person obtaining a copy of this software, associated documentation and/or data (collectively the \"Software\"), free of charge and under any and all copyright rights in the Software, and any and all patent rights owned or freely licensable by each licensor hereunder covering either (i) the unmodified Software as contributed to or provided by such licensor, or (ii) the Larger Works (as defined below), to deal in both (a) the Software, and (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if one is included with the Software (each a \"Larger Work\" to which the Software is contributed by such licensors), without restriction, including without limitation the rights to copy, create derivative works of, display, perform, and distribute the Software and make, use, sell, offer for sale, import, export, have made, and have sold the Software and the Larger Work(s), and to sublicense the foregoing rights on either these or other terms. This license is subject to the following condition: The above copyright notice and either this complete permission notice or at a minimum a reference to the UPL must be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ",
            "title": "The Universal Permissive License (UPL), Version 1.0"
        },
        {
            "location": "/dev/01_license",
            "text": " Oracle licenses the Oracle Coherence Hibernate project under the The Universal Permissive License (UPL), Version 1.0 The Universal Permissive License (UPL), Version 1.0 Subject to the condition set forth below, permission is hereby granted to any person obtaining a copy of this software, associated documentation and/or data (collectively the \"Software\"), free of charge and under any and all copyright rights in the Software, and any and all patent rights owned or freely licensable by each licensor hereunder covering either (i) the unmodified Software as contributed to or provided by such licensor, or (ii) the Larger Works (as defined below), to deal in both (a) the Software, and (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if one is included with the Software (each a \"Larger Work\" to which the Software is contributed by such licensors), without restriction, including without limitation the rights to copy, create derivative works of, display, perform, and distribute the Software and make, use, sell, offer for sale, import, export, have made, and have sold the Software and the Larger Work(s), and to sublicense the foregoing rights on either these or other terms. This license is subject to the following condition: The above copyright notice and either this complete permission notice or at a minimum a reference to the UPL must be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ",
            "title": "License"
        },
        {
            "location": "/dev/04_issue-tracking",
            "text": " The Issue Tracking system for the Coherence Hibernate project is hosted on github.com . It can be found here: https://github.com/coherence-community/coherence-hibernate/issues . ",
            "title": "Issue Tracking"
        },
        {
            "location": "/about/01_overview",
            "text": " The Oracle Coherence Hibernate project encompasses the code of integration points between Hibernate and Oracle Coherence . Currently, the set of integration points consists of the following modules: A Hibernate-based implementation of the Coherence CacheStore SPI A Coherence-based implementation of the Hibernate second-level cache SPI Complete source code together with documentation is provided via the GitHub repository at https://github.com/coherence-community/coherence-hibernate . ",
            "title": "Overview"
        },
        {
            "location": "/about/01_overview",
            "text": " cached Hibernate Cache Hibernate Second Level Cache SPI arrow_circle_up CacheStore Hibernate as the implementation of a Coherence CacheStore format_list_bulleted Samples Sample Applications. code Javadocs Browse the Coherence Hibernate JavaDocs. ",
            "title": "Documentation"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " Installing the Coherence Hibernate CacheStore implementation amounts to obtaining a distribution of coherence-hibernate-cache-store-3.0.3-SNAPSHOT.jar and making it available to JVM ClassLoaders. The easiest way to do so is to build and execute your Hibernate application with Maven, and add the following dependency to your application&#8217;s pom.xml : <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.hibernate&lt;/groupId&gt; &lt;artifactId&gt;coherence-hibernate-cache-store&lt;/artifactId&gt; &lt;version&gt;3.0.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; Alternatively, you can download coherence-hibernate-cache-store-3.0.3-SNAPSHOT.jar from a Maven repository (e.g. https://repo1.maven.org/maven2/com/oracle/coherence/hibernate/coherence-hibernate-cache-store/ ) and use the respective jars manually in your application&#8217;s JVM classpath. If you prefer building the project from source, please check out the build instructions . The Coherence Hibernate CacheStore implementation depends at runtime on Oracle Coherence and Hibernate. These dependencies are most easily managed using Maven (Or Gradle), but you must explicitly declare those dependencies as do not transitively include them. ",
            "title": "Installing the Coherence Hibernate CacheStore"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " Hibernate entities written and read via the Hibernate CacheStore module must use the assigned ID generator in Hibernate, and also have a defined ID property. Disable the hibernate.hbm2ddl.auto property in the hibernate.cfg.xml file used by the HibernateCacheStore module to avoid excessive schema updates and possible deadlocks when starting a Coherence cluster with multiple storage members. ",
            "title": "Hibernate Configuration Requirements"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " The following examples illustrate how to configure a simple HibernateCacheStore constructor, which accepts only an entity name. This configures Hibernate by using the default configuration path, which looks for a hibernate.cfg.xml file in the class path. You can also include a resource name or file specification for the hibernate.cfg.xml file as the second &lt;init-param&gt; (set the &lt;param-type&gt; element to java.lang.String for a resource name and java.io.File for a file specification). See the Javadoc for HibernateCacheStore for more information. The following example illustrates a simple coherence-cache-config.xml file used to define a NamedCache cache object named TableA that caches instances of a Hibernate entity ( com.company.TableA ). To define more entity caches, add additional &lt;cache-mapping&gt; elements. <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;TableA&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-name&gt;entityname&lt;/param-name&gt; &lt;param-value&gt;com.company.TableA&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;backing-map-scheme&gt; &lt;read-write-backing-map-scheme&gt; &lt;internal-cache-scheme&gt; &lt;local-scheme&gt;&lt;/local-scheme&gt; &lt;/internal-cache-scheme&gt; &lt;cachestore-scheme&gt; &lt;class-scheme&gt; &lt;class-name&gt; com.oracle.coherence.hibernate.cachestore.HibernateCacheStore &lt;/class-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-type&gt;java.lang.String&lt;/param-type&gt; &lt;param-value&gt;{entityname}&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/class-scheme&gt; &lt;/cachestore-scheme&gt; &lt;/read-write-backing-map-scheme&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; The next example illustrates that you can also use the predefined The next example illustrates that you can also use the predefined `+{cache-name}+` macro to eliminate the need for the ` ` portion of the cache mapping. macro to eliminate the need for the &lt;init-params&gt; portion of the cache mapping. <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;TableA&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;backing-map-scheme&gt; &lt;read-write-backing-map-scheme&gt; &lt;internal-cache-scheme&gt; &lt;local-scheme&gt;&lt;/local-scheme&gt; &lt;/internal-cache-scheme&gt; &lt;cachestore-scheme&gt; &lt;class-scheme&gt; &lt;class-name&gt; com.oracle.coherence.hibernate.cachestore.HibernateCacheStore &lt;/class-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-type&gt;java.lang.String&lt;/param-type&gt; &lt;param-value&gt;com.company.{cache-name}&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/class-scheme&gt; &lt;/cachestore-scheme&gt; &lt;/read-write-backing-map-scheme&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; The final example illustrates that, if naming conventions allow, the mapping can be completely generalized to enable a cache mapping for any qualified class name (entity name). <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;com.company.*&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;backing-map-scheme&gt; &lt;read-write-backing-map-scheme&gt; &lt;internal-cache-scheme&gt; &lt;local-scheme&gt;&lt;/local-scheme&gt; &lt;/internal-cache-scheme&gt; &lt;cachestore-scheme&gt; &lt;class-scheme&gt; &lt;class-name&gt; com.oracle.coherence.hibernate.cachestore.HibernateCacheStore &lt;/class-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-type&gt;java.lang.String&lt;/param-type&gt; &lt;param-value&gt;{cache-name}&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/class-scheme&gt; &lt;/cachestore-scheme&gt; &lt;/read-write-backing-map-scheme&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; ",
            "title": "Configuring a HibernateCacheStore Constructor"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " While the provided HibernateCacheStore module provides a solution for most entity-based caches, there may be cases where an application-specific, Hibernate-based CacheStore module is necessary. For example, for providing parameterized queries, or including or post-processing query results. Care must be taken in this scenario to avoid causing re-entrant calls into Coherence cache services, which could be possible (depending on service names) if Hibernate is also configured to use the Coherence-based second-level cache implementation. Therefore, all methods in a custom Hibernate-based CacheLoader or CacheStore implementation should be careful to call the Hibernate Session.setCacheMode(CacheMode.IGNORE) method to disable cache access. Better yet, the Hibernate configuration used by the custom Hibernate-based CacheStore should disable second-level caching. In some cases, you may want to extend the provided HibernateCacheStore with application-specific functionality. The most obvious reason for this is to take advantage of a preexisting, programmatically configured SessionFactory instance. But note that it is possible to inject a pre-configured SessionFactory instance into the provided HibernateCacheStore via Spring integration. ",
            "title": "Creating a Custom Hibernate-Based CacheStore"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " In cases where all access to a database is through Coherence, cache store modules naturally enforce ANSI-style repeatable read isolation as read operations, and write operations are executed serially on a per-key basis (by using the Partitioned Cache Service). Increasing database isolation above the repeatable read level does not yield increased isolation because cache store operations might span multiple partitioned cache nodes (and thus multiple database transactions). Using database isolation levels below the repeatable read level does not result in unexpected anomalies, and might reduce processing load on the database server. ",
            "title": "JDBC Isolation Level"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " For single-cache-entry updates, cache store operations are fully fault-tolerant in that the cache and database are guaranteed to be consistent during any server failure (including failures during partial updates). While the mechanisms for fault-tolerance vary, this is true for both write-through and write-behind caches. Coherence does not support two-phase cache store operations across multiple cache store instances. In other words, if two cache entries are updated, triggering calls to cache store modules sitting on separate servers, it is possible for one database update to succeed and for the other to fail. In this case, you might want to use a cache-aside architecture (updating the cache and database as two separate components of a single transaction) with the application server transaction manager. In many cases, it is possible to design the database schema to prevent logical commit failures (but obviously not server failures). Write-behind caching avoids this issue because put operations are not affected by database behavior (and the underlying issues have been addressed earlier in the design process). ",
            "title": "Fault-Tolerance for Hibernate Cache Store Operations"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " There are two scenarios where using fully cached data sets would be advantageous. One is when you are performing distributed queries on the cache; the other is when you want to provide continued application processing despite a database failure. Distributed queries offer the potential for lower latency, higher throughput, and less database server load, as opposed to executing queries on the database server. For set-oriented queries, the data set must be entirely cached to produce correct query results. More precisely, for a query issued against the cache to produce correct results, the query must not depend on any uncached data. Distributed queries enable you to create hybrid caches. For example, it is possible to combine two uses of NamedCache: a fully cached size-limited data set for querying (for example, the data for the most recent week), and a partially cached historical data set used for singleton read operations. This approach avoids data duplication and minimizes memory usage. While fully cached data sets are usually bulk-loaded during application startup (or on a periodic basis), cache store integration can be used to ensure that both cache and database are kept fully synchronized. Another reason for using fully cached data sets is to provide the ability to continue application processing even if the underlying database fails. Using write-behind caching extends this mode of operation to support full read-write applications. With write-behind, the cache becomes (in effect) the temporary system of record. Should the database fail, updates are queued in Coherence until the connection is restored. At this point, all cache changes are sent to the database. ",
            "title": "Using Fully Cached Data Sets"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " The Oracle Coherence Hibernate Integration project includes a default entity-based CacheStore implementation, HibernateCacheStore , and a corresponding CacheLoader implementation, HibernateCacheLoader , in the com.oracle.coherence.hibernate.cachestore package. The following table describes the different constructors for the HibernateCacheStore and HibernateCacheLoader classes. For more detailed technical information, see the Javadoc for these classes: Constructor Description HibernateCacheLoader() and HibernateCacheStore() These constructors are the default constructors for creating a new instance of a cache loader or cache store. They do not create a Hibernate SessionFactory object. To inject a Hibernate SessionFactory object after you use these constructors, call the setSessionFactory() method. HibernateCacheLoader(java.lang.String entityName) and HibernateCacheStore(java.lang.String entityName) These constructors create a Hibernate SessionFactory object using the default Hibernate configuration (hibernate.cfg.xml) in the classpath. HibernateCacheStore(java.lang.String entityName, java.lang.String sResource) and HibernateCacheStore(java.lang.String entityName, java.lang.String sResource) These constructors create a Hibernate SessionFactory object based on the configuration file provided (sResource). HibernateCacheLoader(java.lang.String entityName, java.io.File configurationFile) and HibernateCacheStore(java.lang.String entityName, java.io.File configurationFile) These constructors create a Hibernate SessionFactory object based on the configuration file provided (configurationFile). HibernateCacheStore(java.lang.String entityName, org.hibernate.SessionFactory sFactory) and HibernateCacheStore(java.lang.String entityName, org.hibernate.SessionFactory sFactory) These constructors accept an entity name name and a Hibernate SessionFactory. ",
            "title": "API for HibernateCacheStore and HibernateCacheLoader"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " This page describes how you can use Hibernate as the implementation of a Coherence CacheStore . Using Hibernate as the implementation of a Coherence CacheStore may be a good fit for Java applications that use Coherence APIs for data access and management, whose cache entries are objects or graphs appropriate for mapping to relational tables via Hibernate, and that have simple transactional requirements (e.g. transactions affecting a single cache entry at a time). Installing the Coherence Hibernate CacheStore Installing the Coherence Hibernate CacheStore implementation amounts to obtaining a distribution of coherence-hibernate-cache-store-3.0.3-SNAPSHOT.jar and making it available to JVM ClassLoaders. The easiest way to do so is to build and execute your Hibernate application with Maven, and add the following dependency to your application&#8217;s pom.xml : <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.hibernate&lt;/groupId&gt; &lt;artifactId&gt;coherence-hibernate-cache-store&lt;/artifactId&gt; &lt;version&gt;3.0.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; Alternatively, you can download coherence-hibernate-cache-store-3.0.3-SNAPSHOT.jar from a Maven repository (e.g. https://repo1.maven.org/maven2/com/oracle/coherence/hibernate/coherence-hibernate-cache-store/ ) and use the respective jars manually in your application&#8217;s JVM classpath. If you prefer building the project from source, please check out the build instructions . The Coherence Hibernate CacheStore implementation depends at runtime on Oracle Coherence and Hibernate. These dependencies are most easily managed using Maven (Or Gradle), but you must explicitly declare those dependencies as do not transitively include them. Hibernate Configuration Requirements Hibernate entities written and read via the Hibernate CacheStore module must use the assigned ID generator in Hibernate, and also have a defined ID property. Disable the hibernate.hbm2ddl.auto property in the hibernate.cfg.xml file used by the HibernateCacheStore module to avoid excessive schema updates and possible deadlocks when starting a Coherence cluster with multiple storage members. Configuring a HibernateCacheStore Constructor The following examples illustrate how to configure a simple HibernateCacheStore constructor, which accepts only an entity name. This configures Hibernate by using the default configuration path, which looks for a hibernate.cfg.xml file in the class path. You can also include a resource name or file specification for the hibernate.cfg.xml file as the second &lt;init-param&gt; (set the &lt;param-type&gt; element to java.lang.String for a resource name and java.io.File for a file specification). See the Javadoc for HibernateCacheStore for more information. The following example illustrates a simple coherence-cache-config.xml file used to define a NamedCache cache object named TableA that caches instances of a Hibernate entity ( com.company.TableA ). To define more entity caches, add additional &lt;cache-mapping&gt; elements. <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;TableA&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-name&gt;entityname&lt;/param-name&gt; &lt;param-value&gt;com.company.TableA&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;backing-map-scheme&gt; &lt;read-write-backing-map-scheme&gt; &lt;internal-cache-scheme&gt; &lt;local-scheme&gt;&lt;/local-scheme&gt; &lt;/internal-cache-scheme&gt; &lt;cachestore-scheme&gt; &lt;class-scheme&gt; &lt;class-name&gt; com.oracle.coherence.hibernate.cachestore.HibernateCacheStore &lt;/class-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-type&gt;java.lang.String&lt;/param-type&gt; &lt;param-value&gt;{entityname}&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/class-scheme&gt; &lt;/cachestore-scheme&gt; &lt;/read-write-backing-map-scheme&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; The next example illustrates that you can also use the predefined The next example illustrates that you can also use the predefined `+{cache-name}+` macro to eliminate the need for the ` ` portion of the cache mapping. macro to eliminate the need for the &lt;init-params&gt; portion of the cache mapping. <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;TableA&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;backing-map-scheme&gt; &lt;read-write-backing-map-scheme&gt; &lt;internal-cache-scheme&gt; &lt;local-scheme&gt;&lt;/local-scheme&gt; &lt;/internal-cache-scheme&gt; &lt;cachestore-scheme&gt; &lt;class-scheme&gt; &lt;class-name&gt; com.oracle.coherence.hibernate.cachestore.HibernateCacheStore &lt;/class-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-type&gt;java.lang.String&lt;/param-type&gt; &lt;param-value&gt;com.company.{cache-name}&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/class-scheme&gt; &lt;/cachestore-scheme&gt; &lt;/read-write-backing-map-scheme&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; The final example illustrates that, if naming conventions allow, the mapping can be completely generalized to enable a cache mapping for any qualified class name (entity name). <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;com.company.*&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-hibernate&lt;/scheme-name&gt; &lt;backing-map-scheme&gt; &lt;read-write-backing-map-scheme&gt; &lt;internal-cache-scheme&gt; &lt;local-scheme&gt;&lt;/local-scheme&gt; &lt;/internal-cache-scheme&gt; &lt;cachestore-scheme&gt; &lt;class-scheme&gt; &lt;class-name&gt; com.oracle.coherence.hibernate.cachestore.HibernateCacheStore &lt;/class-name&gt; &lt;init-params&gt; &lt;init-param&gt; &lt;param-type&gt;java.lang.String&lt;/param-type&gt; &lt;param-value&gt;{cache-name}&lt;/param-value&gt; &lt;/init-param&gt; &lt;/init-params&gt; &lt;/class-scheme&gt; &lt;/cachestore-scheme&gt; &lt;/read-write-backing-map-scheme&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; Creating a Custom Hibernate-Based CacheStore While the provided HibernateCacheStore module provides a solution for most entity-based caches, there may be cases where an application-specific, Hibernate-based CacheStore module is necessary. For example, for providing parameterized queries, or including or post-processing query results. Care must be taken in this scenario to avoid causing re-entrant calls into Coherence cache services, which could be possible (depending on service names) if Hibernate is also configured to use the Coherence-based second-level cache implementation. Therefore, all methods in a custom Hibernate-based CacheLoader or CacheStore implementation should be careful to call the Hibernate Session.setCacheMode(CacheMode.IGNORE) method to disable cache access. Better yet, the Hibernate configuration used by the custom Hibernate-based CacheStore should disable second-level caching. In some cases, you may want to extend the provided HibernateCacheStore with application-specific functionality. The most obvious reason for this is to take advantage of a preexisting, programmatically configured SessionFactory instance. But note that it is possible to inject a pre-configured SessionFactory instance into the provided HibernateCacheStore via Spring integration. JDBC Isolation Level In cases where all access to a database is through Coherence, cache store modules naturally enforce ANSI-style repeatable read isolation as read operations, and write operations are executed serially on a per-key basis (by using the Partitioned Cache Service). Increasing database isolation above the repeatable read level does not yield increased isolation because cache store operations might span multiple partitioned cache nodes (and thus multiple database transactions). Using database isolation levels below the repeatable read level does not result in unexpected anomalies, and might reduce processing load on the database server. Fault-Tolerance for Hibernate Cache Store Operations For single-cache-entry updates, cache store operations are fully fault-tolerant in that the cache and database are guaranteed to be consistent during any server failure (including failures during partial updates). While the mechanisms for fault-tolerance vary, this is true for both write-through and write-behind caches. Coherence does not support two-phase cache store operations across multiple cache store instances. In other words, if two cache entries are updated, triggering calls to cache store modules sitting on separate servers, it is possible for one database update to succeed and for the other to fail. In this case, you might want to use a cache-aside architecture (updating the cache and database as two separate components of a single transaction) with the application server transaction manager. In many cases, it is possible to design the database schema to prevent logical commit failures (but obviously not server failures). Write-behind caching avoids this issue because put operations are not affected by database behavior (and the underlying issues have been addressed earlier in the design process). Using Fully Cached Data Sets There are two scenarios where using fully cached data sets would be advantageous. One is when you are performing distributed queries on the cache; the other is when you want to provide continued application processing despite a database failure. Distributed queries offer the potential for lower latency, higher throughput, and less database server load, as opposed to executing queries on the database server. For set-oriented queries, the data set must be entirely cached to produce correct query results. More precisely, for a query issued against the cache to produce correct results, the query must not depend on any uncached data. Distributed queries enable you to create hybrid caches. For example, it is possible to combine two uses of NamedCache: a fully cached size-limited data set for querying (for example, the data for the most recent week), and a partially cached historical data set used for singleton read operations. This approach avoids data duplication and minimizes memory usage. While fully cached data sets are usually bulk-loaded during application startup (or on a periodic basis), cache store integration can be used to ensure that both cache and database are kept fully synchronized. Another reason for using fully cached data sets is to provide the ability to continue application processing even if the underlying database fails. Using write-behind caching extends this mode of operation to support full read-write applications. With write-behind, the cache becomes (in effect) the temporary system of record. Should the database fail, updates are queued in Coherence until the connection is restored. At this point, all cache changes are sent to the database. API for HibernateCacheStore and HibernateCacheLoader The Oracle Coherence Hibernate Integration project includes a default entity-based CacheStore implementation, HibernateCacheStore , and a corresponding CacheLoader implementation, HibernateCacheLoader , in the com.oracle.coherence.hibernate.cachestore package. The following table describes the different constructors for the HibernateCacheStore and HibernateCacheLoader classes. For more detailed technical information, see the Javadoc for these classes: Constructor Description HibernateCacheLoader() and HibernateCacheStore() These constructors are the default constructors for creating a new instance of a cache loader or cache store. They do not create a Hibernate SessionFactory object. To inject a Hibernate SessionFactory object after you use these constructors, call the setSessionFactory() method. HibernateCacheLoader(java.lang.String entityName) and HibernateCacheStore(java.lang.String entityName) These constructors create a Hibernate SessionFactory object using the default Hibernate configuration (hibernate.cfg.xml) in the classpath. HibernateCacheStore(java.lang.String entityName, java.lang.String sResource) and HibernateCacheStore(java.lang.String entityName, java.lang.String sResource) These constructors create a Hibernate SessionFactory object based on the configuration file provided (sResource). HibernateCacheLoader(java.lang.String entityName, java.io.File configurationFile) and HibernateCacheStore(java.lang.String entityName, java.io.File configurationFile) These constructors create a Hibernate SessionFactory object based on the configuration file provided (configurationFile). HibernateCacheStore(java.lang.String entityName, org.hibernate.SessionFactory sFactory) and HibernateCacheStore(java.lang.String entityName, org.hibernate.SessionFactory sFactory) These constructors accept an entity name name and a Hibernate SessionFactory. ",
            "title": "Coherence Hibernate CacheStore"
        },
        {
            "location": "/about/03_hibernate-cache-store",
            "text": " For an example please see take a look at the Coherence Spring JPA Repository CacheStore Demo. https://github.com/coherence-community/coherence-spring/tree/main/samples/cachestore-demo ",
            "title": "Sample"
        },
        {
            "location": "/dev/07_getting-help",
            "text": " The Coherence Slack channel is the best place to start asking questions - should you need to. Join Slack here . ",
            "title": "Slack"
        },
        {
            "location": "/dev/07_getting-help",
            "text": " Coherence Hibernate&#8217;s source code, including tests and examples, is hosted on GitHub. The source code repository is a great place to start looking for implementation tips. The source code is located at: https://github.com/coherence-community/coherence-hibernate ",
            "title": "Source Code, Tests and Examples"
        },
        {
            "location": "/dev/07_getting-help",
            "text": " If you find an issue with the Coherence Hibernate project or have an idea for a new feature the best place to start is with the Issue Tracking System. All issues, both current and past are publicly viewable. The Issue Tracking System can be found here: https://github.com/coherence-community/coherence-hibernate/issues ",
            "title": "Issue Tracking System"
        },
        {
            "location": "/dev/07_getting-help",
            "text": " Alternatively Oracle Coherence customers can file Support Requests (SR) against the Coherence Product, clearly specifying that requests are for a Coherence Community project. ",
            "title": "Oracle Support"
        },
        {
            "location": "/dev/07_getting-help",
            "text": " There are many avenues to receive help when using the Coherence Hibernate project. Here are a few options. Slack The Coherence Slack channel is the best place to start asking questions - should you need to. Join Slack here . Source Code, Tests and Examples Coherence Hibernate&#8217;s source code, including tests and examples, is hosted on GitHub. The source code repository is a great place to start looking for implementation tips. The source code is located at: https://github.com/coherence-community/coherence-hibernate Issue Tracking System If you find an issue with the Coherence Hibernate project or have an idea for a new feature the best place to start is with the Issue Tracking System. All issues, both current and past are publicly viewable. The Issue Tracking System can be found here: https://github.com/coherence-community/coherence-hibernate/issues Oracle Support Alternatively Oracle Coherence customers can file Support Requests (SR) against the Coherence Product, clearly specifying that requests are for a Coherence Community project. ",
            "title": "Getting Help"
        }
 ]
}