<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CoherenceRegionFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Coherence Hibernate Website</a> &gt; <a href="../index.html" class="el_bundle">coherence-hibernate-cache-6</a> &gt; <a href="index.source.html" class="el_package">com.oracle.coherence.hibernate.cache.v6</a> &gt; <span class="el_source">CoherenceRegionFactory.java</span></div><h1>CoherenceRegionFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2024, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */
package com.oracle.coherence.hibernate.cache.v6;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.oracle.coherence.hibernate.cache.v6.access.CoherenceDomainDataRegionImpl;
import com.oracle.coherence.hibernate.cache.v6.access.CoherenceStorageAccessImpl;
import com.oracle.coherence.hibernate.cache.v6.configuration.session.SessionType;
import com.oracle.coherence.hibernate.cache.v6.configuration.support.Assert;
import com.oracle.coherence.hibernate.cache.v6.configuration.support.CoherenceHibernateProperties;
import com.oracle.coherence.hibernate.cache.v6.configuration.support.CoherenceHibernateSystemPropertyResolver;
import com.oracle.coherence.hibernate.cache.v6.configuration.support.ConfigUtils;
import com.oracle.coherence.hibernate.cache.v6.region.CoherenceRegion;
import com.tangosol.net.CacheFactory;
import com.tangosol.net.Cluster;
import com.tangosol.net.DefaultCacheServer;
import com.tangosol.net.ExtensibleConfigurableCacheFactory;
import com.tangosol.net.NamedCache;
import com.tangosol.net.Session;
import com.tangosol.net.options.WithClassLoader;
import com.tangosol.net.options.WithConfiguration;
import org.hibernate.boot.registry.selector.spi.StrategySelector;
import org.hibernate.boot.spi.SessionFactoryOptions;
import org.hibernate.cache.cfg.spi.DomainDataRegionBuildingContext;
import org.hibernate.cache.cfg.spi.DomainDataRegionConfig;
import org.hibernate.cache.internal.DefaultCacheKeysFactory;
import org.hibernate.cache.spi.CacheKeysFactory;
import org.hibernate.cache.spi.DomainDataRegion;
import org.hibernate.cache.spi.access.AccessType;
import org.hibernate.cache.spi.support.DomainDataStorageAccess;
import org.hibernate.cache.spi.support.RegionFactoryTemplate;
import org.hibernate.cache.spi.support.RegionNameQualifier;
import org.hibernate.cache.spi.support.StorageAccess;
import org.hibernate.cfg.Environment;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A CoherenceRegionFactory is a factory for regions of Hibernate second-level cache implemented with Oracle Coherence.
 *
 * @author Randy Stafford
 * @author Gunnar Hillert
 * @since 2.1
 */
public class CoherenceRegionFactory extends RegionFactoryTemplate {
<span class="nc" id="L54">    private static final Logger LOGGER = LoggerFactory.getLogger(CoherenceRegionFactory.class);</span>

    private static final long serialVersionUID = -8434943540794407358L;

    protected transient CoherenceHibernateSystemPropertyResolver systemPropertyResolver;

    protected transient Session coherenceSession;

    private final boolean requiresShutDown;

    private transient DefaultCacheServer defaultCacheServer;

<span class="nc" id="L66">    private Cluster cluster = null;</span>

    /**
     * Default constructor. Any Coherence instances created will implicitly require a shutdown of Coherence when
     * {@link #stop()} is called via {@link #releaseFromUse()}. This option will by default start Coherence as a
     * Cache client. This means that Coherence services are disabled by default (e.g. Local Storage). You can
     * start Coherence as a CacheServer and local storage will be enabled by default and all default services will be
     * started as well. Please provide property {@link CoherenceHibernateProperties#START_CACHE_SERVER_PROPERTY_NAME}
     */
<span class="nc" id="L75">    public CoherenceRegionFactory() {</span>
<span class="nc" id="L76">        this.coherenceSession = null;</span>
<span class="nc" id="L77">        this.requiresShutDown = true;</span>
<span class="nc" id="L78">    }</span>

    /**
     * Constructor that allows to pass-in an externally created Coherence {@link Session}. In this case the external
     * caller is responsible for any needed Coherence shut-downs when {@link #stop()} is called via {@link #releaseFromUse()}.
     * This means that call to {@link #stop()} will NOT result in a shutdown of Coherence; only the {@link Session} is
     * closed.
     *
     * @param coherenceSession must not be null
     */
<span class="nc" id="L88">    public CoherenceRegionFactory(Session coherenceSession) {</span>
<span class="nc" id="L89">        Assert.notNull(coherenceSession, &quot;The passed-in coherenceSession must not be null.&quot;);</span>
<span class="nc" id="L90">        this.coherenceSession = coherenceSession;</span>
<span class="nc" id="L91">        this.requiresShutDown = false;</span>
<span class="nc" id="L92">    }</span>

    /**
     * The Hibernate settings object; may contain user-supplied &quot;minimal puts&quot; setting.
     */
    private transient SessionFactoryOptions sessionFactoryOptions;

    /**
     * The Hibernate {@link CacheKeysFactory} to use. Hibernate ships with 2 {@link CacheKeysFactory}
     * implementations:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{{@link org.hibernate.cache.internal.DefaultCacheKeysFactory}}
     *   &lt;li&gt;{@link org.hibernate.cache.internal.SimpleCacheKeysFactory}
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If none is specified, then the {@link org.hibernate.cache.internal.DefaultCacheKeysFactory} is used.
     */
    private transient CacheKeysFactory cacheKeysFactory;

    @Override
    protected CacheKeysFactory getImplicitCacheKeysFactory() {
<span class="nc" id="L114">        return this.cacheKeysFactory;</span>
    }

    /**
     * Returns the Coherence {@link Session} used by this {@link CoherenceRegionFactory}.
     * @return the Coherence {@link Session}
     */
    public Session getCoherenceSession() {
<span class="nc" id="L122">        return this.coherenceSession;</span>
    }

    /**
     * Sets the Coherence {@link Session} used by this {@link CoherenceRegionFactory}.
     * @param coherenceSession the Coherence {@link Session} used by this CoherenceRegionFactory. May be null.
     */
    protected void setCoherenceSession(Session coherenceSession) {
<span class="nc" id="L130">        this.coherenceSession = coherenceSession;</span>
<span class="nc" id="L131">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="nc" id="L138">        return getClass().getName() + &quot;(&quot; +</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                &quot;coherenceSession=&quot; + ((this.coherenceSession != null) ? this.coherenceSession.toString() : &quot;N/A&quot;) +</span>
                &quot;, sessionFactoryOptions=&quot; + this.sessionFactoryOptions +
                &quot;)&quot;;
    }

    @Override
    protected void prepareForUse(SessionFactoryOptions settings, Map configValues) {
<span class="nc" id="L146">        this.sessionFactoryOptions = settings;</span>

<span class="nc" id="L148">        final CoherenceHibernateProperties coherenceHibernateProperties = new CoherenceHibernateProperties(configValues);</span>

<span class="nc" id="L150">        final Map&lt;String, Object&gt; coherenceProperties = coherenceHibernateProperties.getCoherenceProperties();</span>
<span class="nc" id="L151">        this.systemPropertyResolver = new CoherenceHibernateSystemPropertyResolver(coherenceProperties);</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (this.systemPropertyResolver.getProperty(CoherenceHibernateProperties.COHERENCE_LOGGER_PROPERTY_NAME) == null) {</span>
<span class="nc" id="L154">            this.systemPropertyResolver.addCoherenceProperty(CoherenceHibernateProperties.COHERENCE_LOGGER_PROPERTY_NAME, CoherenceHibernateProperties.COHERENCE_LOGGER_DEFAULT_VALUE);</span>
        }

<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (this.sessionFactoryOptions != null) {</span>
<span class="nc" id="L158">            final StrategySelector selector = this.sessionFactoryOptions.getServiceRegistry().getService(StrategySelector.class);</span>
<span class="nc" id="L159">            this.cacheKeysFactory = selector.resolveDefaultableStrategy(CacheKeysFactory.class,</span>
<span class="nc" id="L160">                    configValues.get(Environment.CACHE_KEYS_FACTORY), new DefaultCacheKeysFactory());</span>
<span class="nc" id="L161">        }</span>
        else {
<span class="nc" id="L163">            this.cacheKeysFactory = new DefaultCacheKeysFactory();</span>
        }

<span class="nc" id="L166">        this.systemPropertyResolver.initialize();</span>

<span class="nc" id="L168">        prepareCoherenceSessionIfNeeded(coherenceHibernateProperties);</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L171">            LOGGER.debug(&quot;start({}, {})&quot;, settings, configValues);</span>
        }
<span class="nc" id="L173">    }</span>

    private void prepareCoherenceSessionIfNeeded(CoherenceHibernateProperties coherenceHibernateProperties) {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (this.coherenceSession == null) {</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">            if (coherenceHibernateProperties.getSessionType() == null || SessionType.SERVER.equals(coherenceHibernateProperties.getSessionType())) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                if (coherenceHibernateProperties.isStartCacheServer()) {</span>
<span class="nc" id="L179">                    final ExtensibleConfigurableCacheFactory.Dependencies deps =</span>
<span class="nc" id="L180">                            ExtensibleConfigurableCacheFactory.DependenciesHelper.newInstance(coherenceHibernateProperties.getCacheConfigFilePath());</span>

<span class="nc" id="L182">                    final ExtensibleConfigurableCacheFactory cacheFactory = new ExtensibleConfigurableCacheFactory(deps);</span>
<span class="nc" id="L183">                    this.defaultCacheServer = new DefaultCacheServer(cacheFactory);</span>
<span class="nc" id="L184">                    this.defaultCacheServer.startDaemon(5000);</span>
                }

<span class="nc" id="L187">                CacheFactory.ensureCluster();</span>

            }

<span class="nc" id="L191">            final List&lt;Session.Option&gt; sessionOptions = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (coherenceHibernateProperties.getSessionName() != null) {</span>
<span class="nc" id="L194">                sessionOptions.add(ConfigUtils.getSessionNameOption(coherenceHibernateProperties.getSessionName()));</span>
            }

<span class="nc" id="L197">            final Session.Option cacheConfigFilePathOption = WithConfiguration.using(coherenceHibernateProperties.getCacheConfigFilePath());</span>
<span class="nc" id="L198">            final Session.Option classLoaderOption = WithClassLoader.using(getClass().getClassLoader());</span>

<span class="nc" id="L200">            sessionOptions.add(cacheConfigFilePathOption);</span>
<span class="nc" id="L201">            sessionOptions.add(classLoaderOption);</span>

<span class="nc" id="L203">            final Session sessionToSet = Session.create(sessionOptions.toArray(new Session.Option[0]));</span>
<span class="nc" id="L204">            this.setCoherenceSession(sessionToSet);</span>
        }
<span class="nc" id="L206">    }</span>

    @Override
    protected void releaseFromUse() {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (this.getCoherenceSession() != null) {</span>
            try {
<span class="nc" id="L212">                this.coherenceSession.close();</span>
            }
<span class="nc" id="L214">            catch (Exception ex) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (LOGGER.isErrorEnabled()) {</span>
<span class="nc" id="L216">                    LOGGER.error(&quot;Unable to close session '{}'.&quot;, this.coherenceSession, ex);</span>
                }
<span class="nc" id="L218">            }</span>
        }

<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (this.requiresShutDown) {</span>
<span class="nc" id="L222">            CacheFactory.getCluster().shutdown();</span>
<span class="nc" id="L223">            CacheFactory.shutdown();</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (this.defaultCacheServer != null) {</span>
<span class="nc" id="L226">                this.defaultCacheServer.shutdownServer();</span>
            }
        }
        else {
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L231">                LOGGER.debug(&quot;Skipping Coherence shutdown as requiresShutDown flag is false.&quot;);</span>
            }
        }

<span class="nc" id="L235">        System.clearProperty(&quot;coherence.log&quot;);</span>
<span class="nc" id="L236">        this.systemPropertyResolver.unset();</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (LOGGER.isInfoEnabled()) {</span>
<span class="nc" id="L239">            LOGGER.info(&quot;Shutdown of Coherence complete.&quot;);</span>
        }

<span class="nc" id="L242">        this.setCoherenceSession(null);</span>
<span class="nc" id="L243">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * see also https://stackoverflow.com/a/12389310/835934
     */
    @Override
    public boolean isMinimalPutsEnabledByDefault() {
<span class="nc" id="L252">        return true;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AccessType getDefaultAccessType() {
<span class="nc" id="L260">        return AccessType.READ_WRITE;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long nextTimestamp() {
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (this.cluster == null) {</span>
<span class="nc" id="L269">            return System.currentTimeMillis();</span>
        }
        else {
<span class="nc" id="L272">            return CacheFactory.ensureCluster().getTimeMillis();</span>
        }
    }

    // ---- Internal

    /**
     * Ensure the initialization of a NamedCache of the argument name.
     * @param cacheName the name of the NamedCache whose initialization to ensure
     * @return a NamedCache for the argument name
     */
    protected NamedCache&lt;?, ?&gt; ensureNamedCache(String cacheName) {
<span class="nc" id="L284">        return this.coherenceSession.getCache(RegionNameQualifier.INSTANCE.qualify(cacheName, getOptions()));</span>
    }

    @Override
    protected DomainDataStorageAccess createDomainDataStorageAccess(DomainDataRegionConfig regionConfig,
                                                                    DomainDataRegionBuildingContext buildingContext) {
<span class="nc" id="L290">        return new CoherenceStorageAccessImpl(</span>
<span class="nc" id="L291">                this.createCoherenceRegion(regionConfig.getRegionName(), buildingContext.getSessionFactory())</span>
        );
    }

    @Override
    protected StorageAccess createTimestampsRegionStorageAccess(
            String regionName,
            SessionFactoryImplementor sessionFactory) {
<span class="nc" id="L299">        return new CoherenceStorageAccessImpl(this.createCoherenceRegion(regionName, sessionFactory));</span>
    }

    @Override
    protected StorageAccess createQueryResultsRegionStorageAccess(String regionName, SessionFactoryImplementor sessionFactory) {
<span class="nc" id="L304">        return new CoherenceStorageAccessImpl(this.createCoherenceRegion(regionName, sessionFactory));</span>
    }

    protected CoherenceRegion createCoherenceRegion(final String unqualifiedRegionName,
                                                    final SessionFactoryImplementor sessionFactory) {
<span class="nc" id="L309">        return new CoherenceRegion(this, this.ensureNamedCache(unqualifiedRegionName), sessionFactory.getProperties());</span>
    }

    @Override
    public DomainDataRegion buildDomainDataRegion(final DomainDataRegionConfig regionConfig,
                                                  final DomainDataRegionBuildingContext buildingContext) {
<span class="nc" id="L315">        return new CoherenceDomainDataRegionImpl(</span>
                regionConfig,
                this,
<span class="nc" id="L318">                createDomainDataStorageAccess(regionConfig, buildingContext),</span>
                this.cacheKeysFactory,
                buildingContext
        );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>